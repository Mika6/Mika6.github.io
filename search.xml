<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS中继承的写法]]></title>
    <url>%2F2019%2F04%2F27%2F012-JS%E4%B8%AD%E7%BB%A7%E6%89%BF%E7%9A%84%E5%86%99%E6%B3%95%2F</url>
    <content type="text"><![CDATA[原型链继承123456789101112131415function Sup&#123; this.supName = 'sup' this.arr = [1, 2, 3]&#125;Sup.prototype.getSupName = function()&#123; console.log(this.supName)&#125;function Sub()&#123; this.subName = 'sub'&#125;Sub.prototype.getSubName = function()&#123; console.log(this.subName)&#125;Sub.prototype = new Sup() 缺点：父类的引用属性会被子类的实例共享，子类实例不能向父类传参 构造函数继承1234567891011function Sup(name) &#123; this.name = name; this.arr = [1, 2, 3];&#125;Sup.prototype.getName = function() &#123; console.log(this.name);&#125;;function Sub(name, age) &#123; Sup.call(this, name); this.age = age;&#125; 优点：父类引用属性不会被共享；子类构建实例可以传参缺点：父类的方法不能复用（不能继承父类原型的方法） 组合式继承123456789101112function Sup(name) &#123; this.name = name; this.arr = [1, 2, 3];&#125;Sup.prototype.getName = function() &#123; console.log(this.name);&#125;;function Sub(name, age) &#123; Sub.call(this, name); // 一次调用父类构造函数 this.age = age;&#125;Sub.prototype = new Sup(); // 二次调用父类构造函数 优点：父类引用属性不会被共享；子类实例化可以传参；父类方法可以复用缺点：两次调用父类构造函数 原型式继承12345function create(obj) &#123; function F() &#123;&#125; F.prototype = obj; return new F();&#125; 缺点：父类应用属性被共享实际就是对传入的对象执行了一次浅拷贝 寄生式继承1234567function createAnother(obj)&#123; let another = create(obj) another.sag = function()&#123; console.log('hello) &#125; return another&#125; 缺点：不能做到函数复用 寄生组合继承123456789101112131415161718192021function Sup(name) &#123; this.name = name; this.arr = [1, 2, 3];&#125;Sup.prototype.getName = function() &#123; console.log(this.name);&#125;;function Sub(name, age) &#123; Sup.call(this, name); this.age = age;&#125;Sub.prototype.getAge = function() &#123; console.log(this.age);&#125;;// 这里的目的是要继承父类的方法，对父类原型进行浅拷贝function inherit(sub, sup) &#123; let peototype = create(sup.prototype); prototype.constructor = Sub; Sub.prototype = prototype;&#125;inherit(Sub, Sup); 最后继承父类方法还可用以下方式实现： 使用Object.create() 12Sub.prototype = Object.create(Sup.prototype);Sub.prototype.constructor = Sub; ES6 中的Object.setPrototypeOf()可以直接关联，不用手动设置constructor 1Object.setPrototypeOf(Sub.prototype, Sup.prototype); ES6 继承的实现1234567891011121314151617181920class Sup &#123; constuctor(x, y) &#123; console.log(x + y); &#125; toString() &#123; return "sup"; &#125;&#125;class Sub extends Sup &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125; toString() &#123; // 调用父类的toString()方法 return this.color + " " + super.toString(); &#125;&#125;]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端性能优化小结]]></title>
    <url>%2F2019%2F04%2F24%2F011-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前端性能优化，大方向来讲，可从两方面入手，网络层面与页面渲染层面 网络层面从输入 url 到显示页面，在网络层面主要包含三个过程：1 DNS 解析2 TCP 连接3 HTTP 请求与响应 请求过程优化（http 请求优化）http 请求优化主要有两个方向：1 减少请求次数2 减少单次请求消耗的时间 构建工具性能调优 减少 loader 所做的事情1 用 include、exclude 来避免不必要的转译2 将转移结果缓存文件系统 借助其他工具将第三方依赖单独打包 文件结构可视化，寻找体积过大的原因 删除冗余代码 按需加载 图片性能优化 JPEG/JPE特点： 有损压缩，体积小，加载快，不支持透明使用场景：呈现色彩丰富的图片，如大的背景图，轮播图 png-8/png-24特点：支持透明，体积大使用场景：线条颜色对比强烈的颜色和背景，如 logo SVG特点：文本文件，体积小不失真，兼容性好，但渲染成本较高 base64特点：文本文件，依赖编码，小图标解决方案base64 是一种编码方式，不是图片格式使用 base64 也是为了减少请求次数，是作为 CSS sprite 的补充而存在，是一种用于传输 8bit 字节码的编码方式，通过对图片进行 base64 编码，可以直接将编码结果写入 HTML 或者 CSS，从而减少 http 请求。 webP特点：全能，兼容差google 开发的旨在加快图片加载速度，支持有损压缩与无损压缩 减少网络请求减少网络请求 =&gt; 存储 =&gt; 1 浏览器缓存机制 2 本地存储 浏览器缓存机制缓存能够减少 IO 消耗，提高访问速度，浏览器缓存是一种操作简单、效果显著的前端性能优化手段。浏览器缓存机制包含四个方面(按照资源获取请求优先级)：1 Memory Cache2 Service Worker Cache3 HTTP Cache4 Push Cache Memory Cache 内存中的缓存浏览器最先尝试命中，响应速度最快它与渲染进程存在生死相依的关系，当进程结束后，内存中的数据也就不存在了 Service Worker Cache Service Worker 是一种独立于主线程之外的 JavaScript 线程，它脱离浏览器窗体，因此无法直接访问 DOM。也就使得它的行为无法干扰到页面的性能，因此，借助它我们可以实现离线缓存，消息推送，网络代理等功能。借助 Service Worker 实现的离线缓存就称为Service Work Cache Service Worker 的生命周期包括install, active, working三个阶段。一旦 install ，除非主动终止，就将始终存在，只会在 active 和 working 之间切换。 Service Worker 对协议有要求，以 HTTPS 为前提。 注意：Service Worker 处理网络请求的后台服务，通信使用 postMessageWeb Worker 模仿多线程，通信使用 postMessagewebsocket 在客户端与服务端之间创建一个开放的连接，允许在一个连接导航进行双向通信 HTTP Cachehttp 缓存分为强缓存与协商缓存,强缓存的优先级高于协商缓存，在强缓存命中失败时，才会走协商缓存。 强缓存强缓存是利用 http 头部的 Expries 和 Cache-Control 来控制，当强缓存命中后，不会再与服务器发生通信。服务器返回响应时，在 Response Headers 中将过期时间写入 expires 字段；exprise 是一个时间戳 =&gt; 依赖本地时间 =&gt; 服务器和客户端时间可能不同，也可手动更改 =&gt; 无法达到预期 =&gt; http1.1 增加了 Cache-ControlCache-Control 相对于 expires 更加准确，它的优先级也更高。当 Cache-Control 与 expires 同时出现时，我们以 Cache-Control 为准。 1cache-control: max-age=3600, s-maxage=31536000 s-maxage 优先级高于 max-age，两者同时出现时，优先考虑 s-maxage。如果 s-maxage 未过期，则向代理服务器请求其缓存内容。s-maxage 仅在代理服务器中生效，客户端中我们只考虑 max-age。public 与 privatepublic 与 private 是针对资源是否能够被代理服务缓存而存在的一组对立概念。public：即可被浏览器缓存，又可以被代理服务器缓存。private：默认值，只能被浏览器缓存。no-store 与 no-cacheno-cahe: 不会向浏览器询问，直接向服务器询问 =&gt; 进入协商缓存。no-store：不使用任何缓存，直接向服务器发起请求，并下载完整的响应。 协商缓存协商缓存依赖浏览器与服务器之间的通信协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，如果服务端提示资源未改动，资源会被重定向到浏览器缓存，对应状态码是 304 Not ModifiedLast-Modified 是一个时间戳，首次请求时随着响应头返回下次请求时，会带上 If-Modefied-Since，它的值就是上次返回的 Last-Modified它的缺点：1 我们编辑了文件，但文件的内容没有改变。会被当做新资源，进而引发一次完整的响应——不该重新请求的时候，也会重新请求。2 当我们修改文件的速度过快时（比如花了 100ms 完成了改动），由于 If-Modified-Since 只能检查到以秒为最小计量单位的时间差，所以它是感知不到这个改动的——该重新请求的时候，反而没有重新请求了。=&gt; 于是出现 EtagEtag 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的。首次请求时，响应头部会带有Etag字段下次请求时就会带上一个If-None-Match字段，值为上次 Etag，以供服务器比较Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。 Push CachePush Cache 是指 HTTP2 在 server push 阶段存在的缓存一些特性：Push Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。 本地存储Cookiehttp 是无状态的，Cookie 的本职工作就是用来维持状态的。Cookie 性能缺陷：Cookie 的体积上限为 4KB，超过将被裁剪，只能用来存储少量信息Cookie 是紧跟域名的，默认为 Cookie 页面的主机名，也可手动设置同一个域名下的所有请求都会携带 Cookie，哪怕是一张图片一个 css 文件，容易影响性能。 Web StorageWeb Storage 是 HTML5 专门为浏览器存储而提供的数据存储机制。它又分为 Local Storage 与 Session Storage。 Web Storage 的特点：存储容量大：根据浏览器的不同可达 5-10M仅位于浏览器端，不予服务器发生通信。 Local Storage 与 Session Storage 的区别生命周期：Local Storage 是持久的本地存储，Session Storage 是临时的本地存储，会话级别，页面关闭时，它也就随之释放作用域：两者都遵循同源策略；但 Session Storage 特别的一点在于，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 Session Storage 内容便无法共享。 应用场景Local Storage 在存储方面没有什么特别的限制，理论上 Cookie 无法胜任的、可以用简单的键值对来存取的数据存储任务，都可以交给 Local Storage 来做。Session Storage 更适合用来存储生命周期和它同步的会话级别的信息。 indexDBIndexedDB 是一个运行在浏览器上的非关系型数据库。IndexedDB 可以看做是 LocalStorage 的一个升级，当数据的复杂度和规模上升到了 LocalStorage 无法解决的程度，可以请出 IndexedDB 来帮忙。 页面渲染层服务端渲染服务端渲染 SSR，是一个箱规的概念，对立面是客户端渲染 客户端渲染服务器把要渲染的静态文件发送给客户端，客户端将加载过来的资源，在浏览器里运行一遍 JS，根据 JS 运行结果生成对应的 DOM页面呈现的内容在 html 源文件里是找不到的 服务端渲染，由服务器将需要的组件或者页面渲染成 HTML 字符串，然后把它返回给客户端，客户端加载资源后可直接渲染然后呈现给用户页面呈现的内容在 html 源文件里可以找到 优缺点：首屏体验提升，有利于 SEO本质是把浏览器该做的事分给服务器去做，容易造成服务器压力 浏览器渲染机制浏览器的内核 常见浏览器内核有：Trident（IE）、Gecko(火狐)、Blink(Chrome,Opera)、Webkit(Safari)Blink 是基于 webkit 衍生而来的一个分支各个浏览器下代码渲染具有差异性，其原因就是因为内核的不同，浏览器内核决定了浏览器解释网页语法的方式。浏览器内核可分两个部分：渲染引擎（Layout Engine/Rendering Engine）、JS 引擎。渲染引擎包括了：HTML 解释器、CSS 解释器、布局、网络、存储、图形、音视频、图片解码器等等。HTML 解释器：将 HTML 文档经过词法分析输出 DOM 树。CSS 解释器：将 CSS 文档解析成样式规则。图层布局计算模块：布局计算每个对象的精确位置和大小。视图绘制模块：进行具体节点的图像绘制，将像素渲染到屏幕上。JavaScript 引擎：编译执行 JavaScript 代码。 浏览器渲染过程 1 解析 HTML：这一步浏览器执行了所有加载逻辑，在解析 HTML 的过程中发出了页面渲染需求的各种外部资源请求。2 计算样式： 识别并加载所有的 CSS 样式信息与 DOM 树合并，最终生成页面 render 树(:after :before 这样的伪元素在这个环节被构建到 DOM 中)。3 绘制图层：把每一个页面图层转换为像素，并对所有的媒体文件进行解码。4 整合图层，得到页面：合并各个图层，并将数据由 CPU 输出给 GPU，最终绘制在屏幕上。渲染过程中的一些树 DOM 树：解析 HTML 创建的是 DOM 树(DOM Tree):渲染引擎开始解析 HTML 文档，转换书中的标签得到 DOM 节点，它被称为‘内容树’。 CSSOM 树：解析 CSS 得到就是 CSSOM 树，CSSOM 解析过程与 DOM 解析过程是并行的。 渲染树：CSSOM 与 DOM 结合，之后得到的就是渲染树(Render Tree)。线面两个是动词 布局渲染树：从根节点递归调用，计算每个元素的精确大小、位置，得到基于渲染树的布局渲染树(Layout of hte render tree)。 绘制渲染树：遍历渲染树，使用 UI 后端层来绘制每个节点 CSS 优化CSS 查找样式规则时，是从右往左的性能优化总结：1 避免使用通配符，只对需要永奥的元素进行选择。2 关注可以通过继承实现的属性，避免重复匹配重复定义。3 少食用标签选择器，如果可以，使用类选择器替代。4 id 和 class 选择器不添加多余的标签选择器5 减少嵌套，后代选择器开销最高，应该尽量将选择器的深度降低。 CSS 与 JS 加载优化HTML、CSS、JS都具有阻塞渲染的特性CSS的阻塞浏览器在构建CSSOM的过程中，不会渲染任何已经处理的内容，即使DOM解析完成，只要CSSOM还没完成，渲染这个事情就还没完成。=&gt; DOM 优化首屏渲染优化]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[坑-002-边距重叠问题]]></title>
    <url>%2F2019%2F04%2F22%2F%E5%9D%91-002-%E8%BE%B9%E8%B7%9D%E9%87%8D%E5%8F%A0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[边距重叠问题比邻的两个或多个普通流中的块元素在垂直方向上的外边距会合并为一个外边距水平方向是不会发生重叠的情况 边距计算方法：全部为正值的情况，取值最大的有正有负的情况，分别取绝对值最大的求和都是负值的情况，取绝对值最大的，从零开始负向位移 解决方法 =&gt; 触发BFCBFC：块级格式化上下文原理：1、 属于同一BFC的垂直方向会发生重叠，属于不同BFC的不会重叠2、 BFC的区域不会与浮动元素的box发生重叠3、 BFC是页面上一个独立的容器，里面跟外面不会互相影响4、 计算BFC高度时，浮动元素也参与计算触发条件1、 根元素2、 float不为none3、 position为fixed和absolute4、 overflow为hidden和auto5、 display为inline-block、table-cell、flex、inline-flex 补充：BFC使用场景1、 自适应两栏布局 12.aside&#123;float:left;&#125;.main&#123;overflow:hidden;&#125; 2、清除浮动 12.parent&#123;overflow:hidden;&#125;.child&#123;float:left;&#125; 3、防止垂直边距重叠 12345678910&lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;style&gt;div&#123; overflow:hidden;&#125;&lt;/style&gt;]]></content>
      <categories>
        <category>坑</category>
      </categories>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-605 种花问题]]></title>
    <url>%2F2019%2F04%2F22%2Falgorithm-003-%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目描述假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。 给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。 示例 1: 输入: flowerbed = [1,0,0,0,1], n = 1输出: True示例 2: 输入: flowerbed = [1,0,0,0,1], n = 2输出: False注意: 数组内已种好的花不会违反种植规则。输入的数组长度范围为 [1, 20000]。n 是非负整数，且不会超过输入数组的大小。 问题分析=&gt; 如果题目没有给出1、0的描述，应该首先将问题抽象成出来；=&gt;怎么才能种花？两种情况 =&gt; 边界情况： =&gt; 左边界：00…,01…只有在第第一个位置为0，且第二个位置为零的时候，左边第一个位置才能种花 =&gt; 右边界：…00,…10 右边能不能种花，取决于倒数第二个位置，如果为零，则最右边可以种花 =&gt;中间情况： 000… 只有某元素左右两边都是0的时候，中间该元素才能种花 代码1234567891011121314151617181920212223242526272829let flowers = (field, n) =&gt; &#123; //记录最多能种多少 let count = 0 // 为了最右边位置能够比较左右元素值，这里添加一个默认元素0 field.push(0) for(let i=0, len=field.length-1; i&lt;len; i++)&#123; // 如果i位置上的元素是0，才进行判断，否则直接跳到下个元素 if(field[i] === 0)&#123; if(i === 0 &amp;&amp; field[1] === 0)&#123; count++ // 这里应该多跳过一个元素 i++ &#125;else if(field[i-1] === 0 &amp;&amp; field[i+1] === 0)&#123; count ++ i++ &#125; &#125; &#125; return count &gt;= n&#125;// testlet field1 = [1,0,0,0,1]let field2 = [0,0,1,0,0,0,1,0]let field3 = [0,0,1,0,0,0,1,0,0]console.log('field1-1',flowers(field1, 1)) // trueconsole.log('field1-2',flowers(field1, 2)) // falseconsole.log('field2-2',flowers(field2, 2)) // trueconsole.log('field3-3',flowers(field3, 3)) // true]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-914 卡牌分组]]></title>
    <url>%2F2019%2F04%2F22%2Falgorithm-002-%E5%8D%A1%E7%89%8C%E5%88%86%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目描述给定一副牌，每张牌上都写着一个整数。 此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组： 每组都有 X 张牌。组内所有的牌上都写着相同的整数。仅当你可选的 X &gt;= 2 时返回 true。 示例 1： 输入：[1,2,3,4,4,3,2,1]输出：true解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]示例 2： 输入：[1,1,1,2,2,2,3,3]输出：false解释：没有满足要求的分组。示例 3： 输入：[1]输出：false解释：没有满足要求的分组。示例 4： 输入：[1,1]输出：true解释：可行的分组是 [1,1]示例 5： 输入：[1,1,2,2,2,2]输出：true解释：可行的分组是 [1,1]，[2,2]，[2,2] 提示： 1 &lt;= deck.length &lt;= 100000 &lt;= deck[i] &lt; 10000 问题分析：题目要求每组都有 x 张牌，=&gt; 那么只有当牌上整数对应的数量是 x 的倍数的时候，才能成功分组，=&gt; 也就是要求最大公约数，=&gt; 先对整副牌进行排序，统计不同整数的数量=&gt; 关键点在于求两个数的最大公约数，然后再与其他数求公约数假設兩個數a,b当 a = cb 时，b就是最大公约数当 a = cb + d时，继续寻找 b 和 d 的关系 当 b = d 时，d就是最大公约数 当 b = e*d + f时，继续寻找 d 和 f 的关系重复上述过程，直到能够被整除，这也就是一个递归的过程 代码1234567891011121314151617181920212223242526272829303132let grouping = arr =&gt; &#123; //求兩個數的最大公约数 let greatestComDivisor = (a, b) =&gt; &#123; if (b === 0) &#123; return a; &#125; else &#123; return greatestComDivisor(b, a%b) &#125; &#125;; // 用正则将不同整数分组存放， let cards = arr.sort((x,y)=&gt;x-y).join('').match(/(\d)\1+|\d/g) while(cards.length &gt; 1)&#123; let a = cards.shift().length let b = cards.shift().length let num = greatestComDivisor(a, b) if(num === 1)&#123; return false &#125;else( //插入公约数个#号，进入下一轮比较 cards.unshift('#'.repeat(num)) ) &#125; // 如果cards为空，则没有最大公约数，否则看第一个元素长度，如果大于1，则为true return cards.length ? cards[0].length &gt; 1 : false&#125;;//testlet ret = grouping([1,1,2,2,2,2])console.log(ret) // truelet ret2 = grouping([1,1,1,2,2,2,3,3])console.log(ret2) // false]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-17 电话号码的字母组合]]></title>
    <url>%2F2019%2F04%2F21%2Falgorithm-001-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[题目描述给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 12输入："23"输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]. 说明:尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 问题分析需要根据输入的数字映射到对应的字母，根据输入的数字对进行组合：思路一：循环嵌套思路二：两两组合，然后递归 代码123456789101112131415161718192021222324252627282930313233343536 let phonenum = (str) =&gt; &#123; // 1 建立电话号码键盘映射 let map = ['', '', 'abc', 'def', 'ghi', 'jkl', 'mon', 'pqrs','tuv', 'wxyz'] // 234 =&gt; [2,3,4] let num = str.split('') // 2 保存映射后的内容 23 =&gt; ['abc', 'def'] let code = [] num.forEach(item=&gt;&#123; if(map[item])&#123; code.push(map[item]) &#125; &#125;) // 3. 进行组合 let comb = (arr) =&gt; &#123; // 临时变量用来保存前两项组合的结果 let temp = [] for(let i=0, il = arr[0].length; i&lt;il; i++)&#123; for(let j=0,jl=arr[1].length; j&lt;jl; j++)&#123; temp.push(`$&#123;arr[0][i]&#125;$&#123;arr[1][j]&#125;`) &#125; &#125; arr.splice(0, 2, temp) if(arr.length&gt;1)&#123; comb(arr) &#125;else&#123; return temp &#125; return arr[0] &#125; // 4.调用并返回结果 return comb(code)&#125;//testphonenum('345')// ["dgj", "dgk", "dgl", "dhj", "dhk", "dhl", "dij", "dik", "dil", "egj", "egk", "egl", "ehj", "ehk", "ehl", "eij", "eik", "eil", "fgj", "fgk", "fgl", "fhj", "fhk", "fhl", "fij", "fik", "fil"]]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【坑】之CSS百分比]]></title>
    <url>%2F2019%2F04%2F21%2F%E5%9D%91-001-CSS%E7%99%BE%E5%88%86%E6%AF%94%2F</url>
    <content type="text"><![CDATA[CSS 百分比的坑top, height 百分比参照包含块的高度left, margin, padding, width 百分比参照包含块的宽度translate(-50%, -50%) 百分比参照于自身的宽高background-position 百分参照于（图片区域-图片的位图像素值） 边距重叠问题比邻的两个或多个普通流中的块元素在垂直方向上的外边距会合并为一个外边距，计算]]></content>
      <categories>
        <category>坑</category>
      </categories>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3之flex基本用法小结]]></title>
    <url>%2F2019%2F04%2F20%2F010-CSS3%E4%B9%8Bflex%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[伸缩容器 display 语法 123display: flex | inline-flexflex: 块伸缩容器inline-flex:内联伸缩容器 注意：float,clear,vertical-align在伸缩项目上没有效果 伸缩流方向 flex-direction主要用来定义主轴，从而定义了伸缩项目在容器中的伸缩方向 语法 1flex-direction: row | row-reverse | column | column-reverse 参数功能 row：ltr排版下从左向右排列，rtl排版下从右向左 row-reverse：与row排列相反 column：类似row，方向是从上到下 column-reverse：类似于row-reverse，方向是从下到上 伸缩换行flex-wrap主要用来定义伸缩容器里是单行显示还是多行显示，侧轴的方向决定了新行堆放的方向 语法 1flex-wrap: nowrap | wrap | wrap-reverse 参数功能 nowrap：伸缩容器单行显示，ltr从左到右，rtl从右到左 wrap：伸缩容器多行显示，ltr从左到右，rtl从右到左 wrap-reverse：伸缩容器多行显示，ltr从右到左，rtl从左到右（与wrap相反） 伸缩流方向与换行flex-flow这是flex-direction和flex-wrap属性的简写版,同时定义主轴和侧轴 1flex-flow: &lt;'flex-direction'&gt; | &lt;'flex-wrap'&gt; 参数功能 flex-direction：主轴 flex-wrap：侧轴 注意：flex-flow与writing-mode有直接联系,当使用writing-mode: vertical-rl时转向垂直布局，flex-flow:row将垂直排列伸缩项目，column将水平排列项目 主轴对齐justify-content主要用来设置伸缩项目沿主轴线的对齐方式 语法 1justify-content: flex-start | flex-end | center | space-between | space-around 参数功能 flex-start：伸缩项目向一行的起始位置靠齐。 flex-end：伸缩项目向一行的结束位置靠齐。 center：伸缩项目向一行中间位置靠齐。 space-between：伸缩项目会平均地分布在行里，第一个项目在开始位置，最后一个项目在终点位置。 space-around：伸缩项目会平均分布在行里，两端保留一半的空间。 侧轴对齐align-items和align-self align-items控制伸缩项目在侧轴的对齐方式，align-self控制伸缩项目自身在侧轴的对齐方式。 align-items 语法 1align-items: flex-start | flex-end | center | baseline | stretch 参数功能： flex-start：伸缩项目靠侧轴起始边。 flex-end：伸缩项目在侧轴终点边的外边距靠住该行在侧轴终点边。 center：伸缩项目的外边距盒在该行的侧轴上居中放置。 baseline：伸缩项目根据伸缩项目的基线对齐。 stretch：默认值，伸缩项目拉伸填充整个伸缩容器。 align-self align-self属性主要用来设置单独伸缩项目在侧轴的对齐方式。可以覆盖该伸缩项目的伸缩容器的align-items属性。 语法 1align-self: flex-start | flex-end | center | baseline | stretch 如果伸缩项目的任一个侧轴上的外边距为auto，则align-self没有效果。 伸缩行align-contentalign-content属性会更改flex-wrap的行为，它和align-items相似。主要来调准伸缩行在伸缩容器中的对齐方式，与调准伸缩项目在主轴上对齐方式的justify-content类似。 语法 1align-content: flex-start | flex-end | center | space-between | space-around | stretch 参数功能 flex-start：各行向伸缩容器起点位置堆叠。 flex-end:各行向伸缩容器结束位置堆叠。 center：各行向伸缩容器的中间位置堆叠。 space-between：各行在伸缩容器中平均分布。 space-around：各行在在伸缩容器中平均分布，两边处各有一般的空间。 stretch：默认值，各行将会伸展以占用额外的空间。 伸缩性flex 语法 1flex: none | [&lt;flex-grow&gt; &lt;flex-shrink&gt;? || &lt;flex-basis&gt;] 参数功能 flex-grow: 定义伸缩项目的拉伸因子，默认值0，不可继承。 flex-shrink: 指定了 flex 元素的收缩规则。flex 元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值。默认值为1，不可继承。 flex-basis: 指定了 flex 元素在主轴方向上的初始大小,默认值auto。 大多数情况下，需要将 flex 设置为 auto，initial，none，或一个无单位正数。 flex: 0 auto = flex: initial = felx: 0 1 auto flex: auto = flex: 1 1 auto flex: none = flex: 0 0 auto flex:正数 = flex: 正数 1 0]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文本溢出&内容溢出]]></title>
    <url>%2F2019%2F04%2F20%2F009-%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%26%E5%86%85%E5%AE%B9%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[溢出文本 text-overflow 语法 123text-overflow:clip | ellipsisclip:不显示省略标记...ellipsis:显示省略标记，插入在最后一个字符 三个条件 需要结合强制文本在一行white-space:nowrap 和溢出内容隐藏over-flow:hidden使用 并且需要定义内容宽度width 示例clip:12345678text-overflow-clip&#123; width:100px; padding:10px; border: 1px solid #ccc; text-overflow:clip; /*文本剪切*/ white-space:nowrap; /*强制不换行*/ overflow:hidden; /* 溢出隐藏*/&#125; ellipsis:12345678text-overflow-clip&#123; width:100px; padding:10px; border: 1px solid #ccc; text-overflow:ellipsis; white-space:nowrap; /*强制不换行*/ overflow:hidden; /* 溢出隐藏*/&#125; 内容溢出overflowoverflow是CSS2.1中的特性，CSS3增加了overflow-x和overflow-y 语法 12345/* 定义水平方向内容溢出剪切： */overflow-x:visible | hidden | scroll | auto | no-display | no-content/* 定义垂直方向内容溢出剪切： */overflow-y:visible | hidden | scroll | auto | no-display | no-content 参数功能： visible:默认值，元素将被剪切为包含对象的窗口大小，且clip属性设置失效 auto：在需要时剪切内容并添加滚动条 hidden：内容溢出时，溢出内容将隐藏，且不显示滚动条 scroll：不管内容有没有溢出，都显示滚动条。x, y对应横向和纵向 no-display：内容溢出时不显示元素，类似于添加了display:none no-content：当内容溢出时不显示内容，类似于添加visibility:hidden]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[canvas基础知识小结]]></title>
    <url>%2F2019%2F04%2F20%2F007-canvas%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[总结一些基础知识 画一条直线 moveTo设置起点，lineTo设置下一坐标 123456789101112131415161718192021&lt;canvas id="canvas"&gt;&lt;/canvas&gt;&lt;script&gt; window.onload = function () &#123; var canvas = document.getElementById("canvas"); canvas.width = 800; canvas.height = 800; var context = canvas.getContext("2d"); // 设置状态 context.beginPath(); context.moveTo(100, 100);// 起点 context.lineTo(700, 700);// 下一点坐标 context.closePath(); context.lineWidth = 10;// 线宽 context.strokeStyle = "#0f0";// 颜色 // 绘制 context.stroke(); &#125;&lt;/script&gt; lineCap属性 - 设置线段起始位置的样式，取值如下butt:(default)默认值round:圆头square:方头 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;canvas id="canvas"&gt;&lt;/canvas&gt;&lt;script&gt; window.onload = function () &#123; var canvas = document.getElementById("canvas"); canvas.width = 800; canvas.height = 800; var context = canvas.getContext("2d"); context.lineWidth = 30; context.strokeStyle = "tomato"; context.beginPath(); context.moveTo(100, 100); context.lineTo(400, 100); context.lineCap = "butt"; context.stroke(); context.beginPath(); context.moveTo(100, 200); context.lineTo(400, 200); context.lineCap = "round"; context.stroke(); context.beginPath(); context.moveTo(100, 300); context.lineTo(400, 300); context.lineCap = "square"; context.stroke(); // 辅助线 context.lineWidth = 1; context.beginPath(); context.moveTo(100, 50); context.lineTo(100, 350); context.stroke(); context.beginPath(); context.moveTo(400, 50); context.lineTo(400, 350); context.stroke(); &#125;&lt;/script&gt; 结果如下： lineJoin属性- 两条直线相交处的样式，可取值如下：miter：(default)，尖角，miterLimit 默认值10,控制尖角的长度，只有设置miter时生效。bevel：斜接round: 圆角1234567891011121314151617181920212223242526272829303132333435363738&lt;canvas id="canvas"&gt;&lt;/canvas&gt;&lt;script&gt; window.onload = function () &#123; var canvas = document.getElementById("canvas"); canvas.width = 800; canvas.height = 800; var context = canvas.getContext("2d"); context.lineWidth = 50; context.strokeStyle = "tomato"; context.beginPath(); context.moveTo(300, 300); context.lineTo(400, 100); context.lineTo(500, 300); context.lineJoin = "miter"; context.miterLimit = 10; context.stroke(); context.beginPath(); context.moveTo(300, 500); context.lineTo(400, 300); context.lineTo(500, 500); context.lineJoin = "bevel"; context.miterLimit = 10; context.stroke(); context.beginPath(); context.moveTo(300, 700); context.lineTo(400, 500); context.lineTo(500, 700); context.lineJoin = "round"; context.miterLimit = 10; context.stroke(); &#125;&lt;/script&gt; 示意图如下： 画一个矩形(1).直接使用连线的方式画出矩形。123456789101112131415161718192021222324&lt;canvas id="canvas"&gt;&lt;/canvas&gt;&lt;script&gt; window.onload = function () &#123; var canvas = document.getElementById("canvas"); canvas.width = 800; canvas.height = 800; var context = canvas.getContext("2d"); context.beginPath(); context.moveTo(100, 100); context.lineTo(600, 100); context.lineTo(600, 600); context.lineTo(100, 600); context.lineTo(100, 100);//可以省略，closePath()会自动封闭图形 context.closePath(); context.lineWidth = 10; context.strokeStyle = "#0f0"; context.stroke(); &#125;&lt;/script&gt; (2).使用context.rect(x, y, width, height)规划路径，这里只规划路径，不会绘制。context.fillRect(x, y, width, height), context.strokeRect(x, y, width, height)不但规划路径，还将矩形直接绘制出来。1234567891011121314151617181920212223242526272829303132333435363738&lt;canvas id="canvas"&gt;&lt;/canvas&gt;&lt;script&gt; window.onload = function () &#123; var canvas = document.getElementById("canvas"); canvas.width = 800; canvas.height = 800; var context = canvas.getContext("2d"); drawRect(context, 100, 100, 300, 200, 5, "blue", "red"); drawRect2(context, 250, 200, 300, 200, 5, "blue", "rgba(0, 255, 0, 0.5)"); &#125; function drawRect(cxt, x, y, width, height, borderWidth, borderColor, fillColor)&#123; cxt.beginPath(); cxt.rect(x,y, width, height); // 规划路径 cxt.closePath(); cxt.lineWidth = borderWidth; cxt.fillStyle = fillColor; cxt.strokeStyle = borderColor; cxt.fill(); cxt.stroke(); &#125; function drawRect2(cxt, x, y, width, height, borderWidth, borderColor, fillColor)&#123; cxt.lineWidth = borderWidth; cxt.fillStyle = fillColor; cxt.strokeStyle = borderColor; cxt.fillRect(x, y, width, height); // 填充 cxt.strokeRect(x, y, width, height); &#125;&lt;/script&gt; fillStyle, strokeStyle 可取颜色值如下：#ffffff 、#fff、rgb(255, 255, 100)、rgba(100, 100, 100, 0.8)、hsl(20, 62%, 28%)、 hsla(30, 82%, 45%, 0.6)、red 图形变换 位移：translate(x, y) 旋转：rotate(deg) 缩放：scale(sx, sy) , sx - x方向缩放倍数，sy - y方向缩放倍数。 变换矩阵a c e &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; a - 水平缩放(1) ;&#160;&#160; b - 水平倾斜(0)b d f &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; c - 垂直倾斜(0) ;&#160;&#160; d - 垂直缩放(1)0 0 1 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; e - 水平位移(0);&#160;&#160; f - 垂直位移(0) 设置变换矩阵：transform(a, b, c, d, e, f)setTransform(a, b, c, d, e, f) 设置变换后的默认值 canvas状态的保存与恢复context.save();context.restore();123456789101112131415161718192021222324&lt;canvas id="canvas" style="border: 1px solid #000;"&gt;&lt;/canvas&gt;&lt;script&gt; window.onload = function () &#123; var canvas = document.getElementById("canvas"); canvas.width = 800; canvas.height = 800; var context = canvas.getContext("2d"); context.save(); context.fillStyle = "red"; context.translate(100, 100); context.fillRect(0, 0, 400, 400); context.restore(); context.save(); context.fillStyle = "green"; context.translate(300, 300); context.fillRect(0, 0, 400, 400); context.restore(); &#125;;&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;canvas id="canvas"&gt;&lt;/canvas&gt;&lt;script&gt; window.onload = function () &#123; var canvas = document.getElementById("canvas"); canvas.width = 800; canvas.height = 800; var context = canvas.getContext("2d"); context.fillStyle = "#000"; context.fillRect(0, 0, canvas.width, canvas.height); for(var i = 0; i &lt; 200; i++)&#123; var r = Math.random()*10+10; var x = Math.random()*canvas.width; var y = Math.random()*canvas.height; var a = Math.random()*360; drawStar(context, x, y, r, a) &#125; &#125;; function drawStar(cxt, x, y, R, rot)&#123; var rot = rot || 0; cxt.fillStyle = "#fb3"; cxt.strokeStyle = "#fd5"; cxt.lineWidth = 3; cxt.save(); cxt.transform(R, 0, 0, R, x, y); // cxt.translate(x, y); cxt.rotate(rot/180*Math.PI); // cxt.scale(R, R); starPath(cxt); cxt.fill(); cxt.stroke(); cxt.restore(); &#125; function starPath(cxt)&#123; cxt.beginPath(); for(var i = 0; i &lt; 5; i ++)&#123; cxt.lineTo(Math.cos((18 + i*72 ) / 180 * Math.PI), -Math.sin((18 + i*72) / 180 * Math.PI) ); cxt.lineTo(Math.cos((54 + i*72) / 180 * Math.PI) * 0.5, -Math.sin((54 + i*72 ) / 180 * Math.PI) * 0.5); &#125; cxt.setTransform(1, 0, 0, 1, 0, 0);//清除上一次的影响 cxt.closePath(); &#125;&lt;/script&gt; fillStyle - 线性渐变&amp;径向渐变 线性渐变 //step1 var grd = context.createLinearGradient(xstart, ystart, xend, yend); //step2 grd.addColorStop(stop, color); 12345678910111213141516171819&lt;canvas id="canvas"&gt;&lt;/canvas&gt;&lt;script&gt; window.onload = function () &#123; var canvas = document.getElementById("canvas"); canvas.width = 800; canvas.height = 800; var context = canvas.getContext("2d"); var linearGrad = context.createLinearGradient(0, 0, 800, 800); linearGrad.addColorStop(0.0, 'white'); linearGrad.addColorStop(0.25, 'yellow'); linearGrad.addColorStop(0.5, 'green'); linearGrad.addColorStop(0.75, 'blue'); linearGrad.addColorStop(1.0, 'black'); context.fillStyle = linearGrad; context.fillRect(0, 0, 800, 800); &#125;&lt;/script&gt; 径向渐变 //step1 var grd = context.createRadialGradient(x0, y0, r0, x1, y1, r1); //step2 grd.addColorStop(stop, color); 12345678910111213141516171819&lt;canvas id="canvas"&gt;&lt;/canvas&gt;&lt;script&gt; window.onload = function () &#123; var canvas = document.getElementById("canvas"); canvas.width = 800; canvas.height = 800; var context = canvas.getContext("2d"); var linearGrad = context.createRadialGradient(400, 400, 100, 400, 400, 400); linearGrad.addColorStop(0.0, 'white'); linearGrad.addColorStop(0.25, 'yellow'); linearGrad.addColorStop(0.5, 'green'); linearGrad.addColorStop(0.75, 'blue'); linearGrad.addColorStop(1.0, 'black'); context.fillStyle = linearGrad; context.fillRect(0, 0, 800, 800); &#125;&lt;/script&gt; 5. createPattern createPattern(img, repeat-style)repeat-style:no-repeat; repeat-x; repeat-y; repeat createPattern(canvas, repeat-style) createPattern(video, repeat-style) 曲线绘制圆或圆弧context.arc(context, center, radius, startingAngle, endingAngle, anticlockwiae)anticlockwiae = false 顺时针12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;canvas id="canvas"&gt;&lt;/canvas&gt;&lt;script&gt; window.onload = function()&#123; var canvas = document.getElementById("canvas"); canvas.width = 1024; canvas.height = 768; var context = canvas.getContext("2d"); context.lineWidth = 2; context.strokeStyle = "#058"; for(var i = 0; i &lt; 10; i ++)&#123; context.beginPath(); context.arc(50 + i*100, 60, 40, 0,2*Math.PI*(i+1)/10); context.closePath();//会自动闭合 context.stroke() &#125; for(var i = 0; i &lt; 10; i ++)&#123; context.beginPath(); context.arc(50 + i*100, 180, 40, 0,2*Math.PI*(i+1)/10); context.stroke() &#125; for(var i = 0; i &lt; 10; i ++)&#123; context.beginPath(); context.arc(50 + i*100, 300, 40, 0,2*Math.PI*(i+1)/10, true); context.closePath();//会自动闭合 context.stroke() &#125; for(var i = 0; i &lt; 10; i ++)&#123; context.beginPath(); context.arc(50 + i*100, 420, 40, 0,2*Math.PI*(i+1)/10, true); context.stroke() &#125; context.fillStyle = "#0f0"; for(var i = 0; i &lt; 10; i ++)&#123; context.beginPath(); context.arc(50 + i*100, 540, 40, 0,2*Math.PI*(i+1)/10, true); context.closePath();//会自动闭合 context.fill() &#125; for(var i = 0; i &lt; 10; i ++)&#123; context.beginPath(); context.arc(50 + i*100, 660, 40, 0,2*Math.PI*(i+1)/10, true); context.fill() &#125; &#125;&lt;/script&gt; arcTocontext.arcTo(x1, y1, x2, y2, radius)123456789101112131415&lt;canvas id="canvas"&gt;&lt;/canvas&gt;&lt;script&gt; window.onload = function () &#123; var canvas = document.getElementById("canvas"); canvas.width = 1800; canvas.height = 1800; var context = canvas.getContext("2d"); context.moveTo(400,100) context.arcTo(1200,400,400,700,400); context.strokeStyle= "red" context.stroke() &#125;&lt;/script&gt; 贝赛尔曲线 Bezier（1）QuadraticCurveTo(二次)context.moveTo(x0, y0); //初始点contextquadraticCurveTo(x1, y1, x2, y2)//控制点、结束点（2）BezierCurveTo(三次)context.moveTo(x0, y0);context.bezierCurveTo(x1, y1, x2, y2, x3, y3);12345678910111213141516171819function drawLand(cxt)&#123; cxt.save(); cxt.beginPath(); cxt.moveTo(0, 600); cxt.bezierCurveTo(540, 400, 660, 800, 1200, 600); cxt.lineTo(1200, 800); cxt.lineTo(0, 800); cxt.closePath(); var lanStyle = cxt.createLinearGradient(0, 800, 0, 0); lanStyle.addColorStop(0.0, "#030"); lanStyle.addColorStop(1.0, "#580"); cxt.fillStyle = lanStyle; cxt.fill(); cxt.restore();&#125; 文字渲染基础context.font = “bold 40px Arial”;context.fillText(String, x, y, [maxlen]);context.StrokeText(String, x, y, [maclen])1234567891011121314151617181920212223&lt;canvas id="canvas"&gt;&lt;/canvas&gt;&lt;script&gt; window.onload = function () &#123; var canvas = document.getElementById("canvas"); canvas.width = 800; canvas.height = 800; var context = canvas.getContext("2d"); context.font = "bold 40px Arial"; context.fillStyle = "#058"; context.fillText("欢迎学习Canvas！欢迎学习Canvas！", 40, 100); context.lineWidth = 1; context.strokeStyle = "#058"; context.strokeText("欢迎学习Canvas！欢迎学习Canvas！", 40, 200); context.fillText("欢迎学习Canvas！欢迎学习Canvas！", 40, 300, 400); context.strokeText("欢迎学习Canvas！欢迎学习Canvas！", 40, 400, 400); &#125;&lt;/script&gt; font默认值”20px sans-serif”（1）font-style:normal(default);italic(斜体字);oblique(倾斜字体)（2）font-variant:normal;small-caps(以小型形式显示大写字母)（3）font-weight:lighter;normal;bold;bolder;100,200,300,400(normal),500,600,700(bold),800,900（4）font-size:20px;2em;150%;（5）font-family:设置多种字体备选；支持@font-faceweb安全字体1234567891011121314151617181920212223242526272829303132&lt;canvas id="canvas"&gt;&lt;/canvas&gt;&lt;script&gt; window.onload = function () &#123; var canvas = document.getElementById("canvas"); canvas.width = 800; canvas.height = 800; var context = canvas.getContext("2d"); context.font = "bold 40px Arial"; var linearGrad = context.createLinearGradient(0, 0, 700, 0); linearGrad.addColorStop(0.0, 'tomato'); linearGrad.addColorStop(0.25, 'yellow'); linearGrad.addColorStop(0.5, 'green'); linearGrad.addColorStop(0.75, 'pink'); linearGrad.addColorStop(1.0, 'red'); context.fillStyle = linearGrad; // context.fillStyle = "#058"; context.fillText("欢迎学习Canvas！欢迎学习Canvas！", 40, 100); context.lineWidth = 1; context.strokeStyle = "#058"; context.strokeText("欢迎学习Canvas！欢迎学习Canvas！", 40, 200); context.fillText("欢迎学习Canvas！欢迎学习Canvas！", 40, 300, 400); context.strokeText("欢迎学习Canvas！欢迎学习Canvas！", 40, 400, 400); &#125;&lt;/script&gt; 文本对齐context.textAlign = left/center/rightcotext.textBaseline = top/middle/bottom (alphabetic拉丁/ideographic汉，日/hanging印) 文本度量context.measureText(String).width 阴影context.shadowColor;context.shadowOffsetX;//x位移值context.shadowOffsetY;//y位移值xontext.shadowBlur; //模糊值 global globalAlpha = 1(default) //使全局具有透明度 glibalCompositeOperation//绘制的图像在重叠时产生的效果“sourece-over” - 后绘制的图像在先绘制的图形上面“destination-over” - 先绘制的图形在后悔值的上面·······················································································source-oversource-atopsource-insource-out·················································································destination-overdestination-atopdestination-indestination-out·················································································lightercopyxor 剪辑区域context.clip(); 剪纸效果非零环绕原则 其他 clearRectcontext.clearRect(x, y, width, height) isPointInPathcontext.isPointInPath(x, y)var x = event.clientX - canvas.getBoundingClientRect().leftvar y = event.clientY - canvas.getBoundingClientRect().Right 兼容性explorecanvas https://code.google.con/p/explorecanvas/canvas 图形库：canvasplus/ArtisanJS/Rgraph]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongoose操作mongoDB笔记]]></title>
    <url>%2F2019%2F04%2F20%2F008-mongoose%E6%93%8D%E4%BD%9CmongoDB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Mongoose第三方包mongoose基于MongoDB官方的mongdb包在一级做了封装 网址： https://mongoosejs.com/ 起步 安装 1npm i mongoose helloworld 123456789101112const mongoose = require('mongoose');mongoose.connect('mongodb://localhost:27017/test', &#123;useNewUrlParser: true&#125;);//创建一个模型，就是在设计数据库const Cat = mongoose.model('Cat', &#123; name: String &#125;);//实例化一个catconst kitty = new Cat(&#123; name: 'Zildjian' &#125;);//持久化保存kitty实例kitty.save().then(() =&gt; console.log('meow')); 官方指南官方增删查改demo 设计Schema发布Model12345678910111213141516171819202122232425262728293031323334353637var mongoose = require('mongoose')var Schema = mongoose.Schema// 1. 连接数据库// 指定连接的数据库不需要存在，当你插入第一条数据之后就会自动被创建出来mongoose.connect('mongodb://localhost/itcast')// 2. 设计文档结构（表结构）// 字段名称就是表结构中的属性名称// 约束的目的是为了保证数据的完整性，不要有脏数据var userSchema = new Schema(&#123; username: &#123; type: String, required: true // 必须有 &#125;, password: &#123; type: String, required: true &#125;, email: &#123; type: String &#125;&#125;)// 3. 将文档结构发布为模型// mongoose.model 方法就是用来将一个架构发布为 model// 第一个参数：传入一个大写名词单数字符串用来表示你的数据库名称// mongoose 会自动将大写名词的字符串生成 小写复数 的集合名称// 例如这里的 User 最终会变为 users 集合名称// 第二个参数：架构 Schema// // 返回值：模型构造函数var User = mongoose.model('User', userSchema)// 4. 当我们有了模型构造函数之后，就可以使用这个构造函数对 users 集合中的数据为所欲为了（增删改查） 增加数据1234567891011121314let admin = new User(&#123; username:'admin', password:'123456', email:'admin@admin.com'&#125;)admin.save((err, ret)=&gt;&#123; if(err)&#123; console.log('err') &#125;else&#123; console.log('success') console.log(ret) &#125;&#125;) 查询查询所有： 1234567User.find((err, ret)=&gt;&#123; if(err)&#123; console.log('err') &#125;else&#123; console.log(ret) &#125;&#125;) 按条件查询所有： 1234567User.find(&#123;username:'ss'&#125;,(err, ret)=&gt;&#123; if(err)&#123; console.log('err') &#125;else&#123; console.log(ret) &#125;&#125;) 按条件查询单个： 123456789User.findOne(&#123; username:'ss'&#125;,(err, ret)=&gt;&#123; if(err)&#123; console.log('err') &#125;else&#123; console.log(ret) &#125;&#125;) 删除数据deleteOne(), deleteMany() 12345678910User.deleteOne(&#123; username:'ss'&#125;,(err, ret)=&gt;&#123; if(err)&#123; console.log('err') &#125;else&#123; console.log('sucdccess') console.log(ret) &#125;&#125;) 更新数据 findByIdAndUpdate() 123456789User.findByIdAndUpdate('5c822c27de309b2e200fac3d',&#123; password:'123'&#125;,(err, ret)=&gt;&#123; if(err)&#123; console.log('err') &#125;else&#123; console.log('success') &#125;&#125;) findeOneAndUpdate() 12345var query = &#123; name: 'borne' &#125;;Model.findOneAndUpdate(query, &#123; name: 'jason bourne' &#125;, options, callback)// is sent asModel.findOneAndUpdate(query, &#123; $set: &#123; name: 'jason bourne' &#125;&#125;, options, callback)]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this指向小结]]></title>
    <url>%2F2019%2F04%2F20%2F006-this%E6%8C%87%E5%90%91%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在全局环境下，this始终指向全局对象（window），无论严格与否 函数上下文调用 函数直接调用 非严格模式：this指向全局对象window 严格模式：this为undefined 对象中的this 函数的定义位置不影响其this指向，this指向只和调用函数的对象有关。 多层嵌套的对象，内部方法的this指向离被调用函数最近的对象（window也是对象，其内部对象调用方法的this指向内部对象， 而非window）。 原型链中的this，指向调用它的对象（谁调用指向谁），以上对于函数作为getter &amp; setter 调用时同样适用。 构造函数中，构造函数中的this与被创建的新对象绑定。 注意：当构造器返回的默认值是一个this引用的对象时，可以手动设置返回其他的对象，如果返回值不是一个对象，返回this。 call&amp;apply 当函数通过Function对象的原型中继承的方法 call() 和 apply() 方法调用时， 其函数内部的this值可绑定到 call() &amp; apply() 方法指定的第一个对象上， 如果第一个参数不是对象，JavaScript内部会尝试将其转换成对象然后指向它。 bind bind方法在ES5引入， 在Function的原型链上， Function.prototype.bind。通过bind方法绑定后， 函数将被永远绑定在其第一个参数对象上， 而无论其在什么情况下被调用。 DOM事件处理函数中的this &amp; 内联事件中的this DOM事件处理函数：当函数被当做监听事件处理函数时，其this指向触发该事件的元素（针对addEvenetListener） 内联事件 当代码被内联处理函数调用时，它的this指向监听器所在元素 当代码被包括在函数内部执行时，其this指向等同于函数直接调用的情况， 在非严格模式下指向全局对象window 在严格模式下指向undefined setTineout&amp;setInterval 对于延时函数内部的回调函数的this指向全局对象window（当然我们可以通过bind方法改变其内部函数的this指向） 箭头函数中的this 由于箭头函数不绑定this， 它会捕获其所在（即定义的位置）上下文的this值， 作为自己的this值， 所以 call() / apply() / bind() 方法对于箭头函数来说只是传入参数，对它的 this 毫无影响。 考虑到 this 是词法层面上的，严格模式中与 this 相关的规则都将被忽略。（可以忽略是否在严格模式下的影响） 作为方法的箭头函数this指向全局window对象，而普通函数则指向调用它的对象 参考：https://www.cnblogs.com/dongcanliang/p/7054176.html]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[== & === & Object.is()]]></title>
    <url>%2F2019%2F04%2F20%2F004-%E5%85%A8%E7%AD%89%E3%80%81%E5%8F%8C%E7%AD%89%E4%B8%8EObject-is%2F</url>
    <content type="text"><![CDATA[== == 会进行隐式类型转换 undefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。 12345678910false == null // falsefalse == undefined // flasenull == undefined // true'' == '0' // false0 == '' // true0 == '0' // truefalse == "false" // falsefalse == '0' // true 一个基本数据类型与一个引用数据类型 ：会将对象转化为它的原始值，在与基本数据类型进行比较。 123var arr = [1,2];var str = "1,2";alert(arr == str); //内部执行valueOf()，将arr值转化为原始值，但是arr并没有变化，显示true === === 严格等于， 要求类型相同，并且值相等；类型不同就会返回false 数值比较时，如果有一个是NaN，则不相等。 NaN === NaN // false 判断一个值是否是NaN可以用isNaN()或者Object.is() +0 === -0 // true Object.is() Object.is() ES6新增的用来比较严格相等的方法，基本行为与 === 一致 不同之处： Object.is(+0, -0) //false Object.is(NaN, NaN) //true]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[for、for...of、for...in]]></title>
    <url>%2F2019%2F04%2F20%2F003-for%E3%80%81for-of%E3%80%81for-in%2F</url>
    <content type="text"><![CDATA[for 、for…of、for…in区别 forEach() foeEach()不能使用break语句跳出循环，或者使用return从函数体内返回 for-in() 为循环“enumerable”对象设计的 循环遍历对象自身和继承的可枚举属性（不含Symbol） 会循环原型链和手动添加的键，返回键名key 某些情况下，循环顺序随机的 for-of()（ES6） 可以使用break,continue,return 支持数组和类数组对象的遍历，循环读取键值 也支持字符串的遍历]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[undefined与null]]></title>
    <url>%2F2019%2F04%2F20%2F002-undefined%E4%B8%8Enull%2F</url>
    <content type="text"><![CDATA[undefined与null的区别undefined与null 都是JS的原始类型， null转换为数值为0，undefined转换为数值为NaN undefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。 undefined 当声明的变量还未被初始化时，变量的默认值为undefined 调用函数时，应该提供的参数没提供，则该参数为undefined 函数没有返回值时，默认返回undefined 对象没有赋值的属性 null null表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象 作为函数的参数，表示参数不是对象 作为对象原型链的终点( Object.getPrototypeOf(Object.prototype) ) 1234567typeof( undefined ) //undefinedtypeof( null ) // objectnull == undefined //truenull === undefined // false]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[css基础知识小结]]></title>
    <url>%2F2019%2F04%2F20%2F001-css%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[选择器1.1 【基本选择器】 通配符 *{ } 元素选择器 body{ } 类选择器 .list{ } ID选择器 #list{ } 后代选择器 .list li { } 1.2 【基本选择器扩展】 子元素选择器 #wrap&gt;.inner{} 相邻兄弟选择器 #wrap+.inner{ } 通用兄弟选择器 #list~li{ } 选择器分组 h1,h2,h3{ } 1.3 【属性选择器】 存在和值属性选择器 [ attr ] 包含attr的所有元素，不论上attr为何值 [ attr=val ] 选中attr为val的值 [ attr~=val ] 带有以attr命名属性的元素，并且改属性是一个以空格作为分隔符的值列表，其中至少包含一个值为val 子串值属性选择器 [ attr|=val ] 选择attr属性的值是val（包括val）或者以val- 开头的元素 [ attr^=val ] 选择attr属性的值以val开（）头的元素 [ attr$=val ] 选择attr属性的值以val结尾（包括）的元素 [ attr*=val ] 选择attr属性的值包含字符串val的 1.4【 伪类伪元素选择器】 链接伪类 :link 未访问 :visited 访问过 :target 代表一个特殊元素，它的id是URI的片段标识符 【坑】：link visited target 只能作用于链接元素 ：hover ：active 几乎可以作用于所有元素 由于a标签的：link 和 : visited可以覆盖所有的a标签的状态，所以当：link ：visited :hover :active同时 作用于a标签时，：link ：visited不能放在最后 注意：：visited选择器，只有一下属性才能被应用到已访问的链接 color background-color border-color 动态伪类 :hover :active 表单伪类 :enabled 匹配可编辑的表单 :disable 匹配被禁用的表单 :checked 匹配被选中的表单 :focus 匹配获焦的表单 结构伪类 nth-child(index)系列 :first-child :last-child :nth-last-child(index) :only-child 相当于：：first-child :last-child或者:nth-child(1) :nth-last-child(1) nth-of-type(index)系列 :first-of-type :last-of-type :nth-last-of-type(index) :only-of-type 相当于：：first-of-type :last-of-type或者：nth-of-type(1) :nth-last-of-type(1) :not 排除某一个 :empty （内容必须为空，空格都不行，有attr没关系） 伪元素选择器 ::after ::before ::first-letter ::first-line ::selection 1.5 【CSS声明的优先级】 1.5.1 选择器的特殊性 选择器的特殊性由选择器本身的组件确定，特殊性值分为四个部分，如 0,0,0,0 一个选择器的具体特殊性如下确定： 对于选择器中给定的ID属性，加 0,1,0,0 对于选择器中给定的各个类属性，属性选择，或伪类，加 0,0,1,0 对于选择器中的给定的各个元素和伪元素，加 0,0,01 通配符选择器的特殊性为 0,0,0,0 结合符对选择器特殊性没有一点贡献 内联声明的特殊性都是 1,0,0,0 ““ 继承没有特殊性 特殊性 1,0,0,0 大于所有以0开头的特殊性（不进位） 选择器特殊性最终都会授予给其对应的声明 如果多个规则与同一个元素匹配，而且有些声明互相冲突时，特殊性大的占优势 1.5.2 重要声明 有时某个声明比较重要，超过了所有的其他声明，CSS2.1就称之为重要声明 并允许在这些声明的结束分号之前插入 !important 来标志 必须要准确的放置 !important 否则无效， !important 总是要放在声明的最后，即分号前面 标志位!important 的声明比呢没有特殊性的特殊值，但要与非重要声明分开考虑 实际上所有的重要声明会被浏览器分为一组，重要声明的冲突会在其内部解决 非重要声明也会被分为一组，非重要声明的冲突也会在其内部解决 如果一个重要声明与非重要声明冲突，生出的总是重要声明 1.5.3 继承 继承没有特殊性，甚至连0特殊性都没有 0特殊性要比无特殊性来得强 1.5.4 来源 CSS样式来源大致三种 创作人员 — 程序员 读者 — 用户代理 – 浏览器 它们的权重如下： 读者的重要声明 创作人员的重要声明 创作人员的正常声明 读者的正常声明 用户代理的声明 1.5.5 层叠 找出所有相关的规则，这些规则额都包含一个选择器 计算声明优先级： 先按来源排序 再按选择器的特殊性排序 最终排序 自定义字体 @font-face @font-face 允许网页开发者为其网页指定在线字体 1234@font-face&#123; font-family:"fontName"; src:url( );&#125; 字体图标 软件：Ai 画矢量图 FontLab 做字体的 站点： www.fontsequirrel.com icommon.io/app/ 新的UI方案 3.1 文本新样式 文字阴影 text-shadow ：color \ \ \ 为文字添加阴影，可以添加多层，阴影值之间用逗号隔开（多个阴影时，第一个在最上面） 默认值 none 不可继承 color 可选 位置可在偏移量之前或之后 offset-x / offset-y 必选 指定水平/垂直偏移量 blur-radius 可选 length值 默认为0 值越大，模糊半径越大 应用：浮雕文字， 文字模糊 文字描边 文字排版 3.2 盒模型新样式 盒模型阴影 box-shadow 默认值：none 不可继承 inset： 默认阴影在外边框，使用inset后，阴影在内边框 offset-x / offset-y length值 设置阴影偏移量 blur-radius 值越大阴影面积越大 不可为负值 spread-radius 取正值时，阴影放大；取负值时阴影收缩；默认为0 color 指定阴影颜色 倒影 -webkit-box-reflect 设置元素倒影 默认值：none 不可继承 第一个值：倒影方向：above, below, right, left 第二个值：倒影距离 长度单位 第三个值： 渐变 resize- box-sizing 允许你控制一个元素可调整大小性 一定要配合overflow:auto使用 默认值：none both 允许在水平和垂直方向调整大小 horizontal 允许在水平方向上调整大小 vertical 允许在垂直方向上调整元素大小 3.3 新增UI样式 3.3.1 圆角 border-radius 默认值：none 不可继承 border-top-left-radius border-top-right-radius border-bottom-right-radius border-bottom-left-radius 3.3.2 边框图片 border-image：\ || \ [/\] || \ 引入背景图片：border-image-source : url( ) 切割图片：border-image-slice : [\ | \] {1,4} &amp;&amp; fill ? 这里number没有单位，默认就是像素 图片宽度：border-image-width：[\ | \ |\ | auto]{1,4} 排列方式：[strench | repeat | round] {1,2} 3.3.3 背景 CSS2 1.background-color：transparent || \ 2.background-image: none || \ 3.background-repeat: repeat || repeat-x || repeat-y || no-repeat 4.background-position: \ || \ || [left|center|rigt] [,top|center|bottom] 百分比计算是定位区域的尺寸减去背景图片的尺寸 background-attachment: scroll || fixed 设置元素背景图片是否固定或者随页面其余部分滚动 CSS3 1.background-origin：padding-box || border-box || content-box 决定backgroung-image的参考原点 默认情况下背景图片是从padding-box开始绘制，从border-box开始剪裁 2.background-clip: border-box || padding-box || content-box 背景颜色也会剪掉 -webkit-background-clip:text 按文字剪切背景 3.background-size: auto || length || percentage || cover || contain 百分比相对于背景区域 单值时，另一个auto 4.background-break 只支持firefox background 简写 3.3.4 渐变 线性渐变 linear-gradient ([[\ | to \],]?\[,color-stop&gt;]+) 例子 发廊灯/光斑动画 径向渐变 radial-gradient([\ || \ [at \]?, | at \,]?\[,\]+) 改变形状：shape circle（圆） ellipse（椭圆） 渐变形状的大小 size closest-side 离圆心最近的边 closest-corner 距离圆心最近的角 farthest-side 离圆心最远的边 farthest-corner 离圆心最远的角 改变圆心的位置 position 默认值为center 过渡 transition-property: none | all | property transition-duration:\[,\]* 一定要带单位，如果不带单位，多个时间的时候，会使其他失效 如 1s, 0, 3s transition-timing-function: ease (先快后慢) linear 匀速 ease-in 加速 ease-out 减速 ease-in-out 先加速再减速 cubic-bezier(p0, p1, p2, p3) transition-delay:\ 延时 注意： 1.transition在元素首次渲染还没有结束的情况下，是不会被触发的 2.在绝大部分变换样式切换时，如果变换函数的位置个数不同也不会触发过渡 3.过渡只关心元素的初始状态和结束状态，没有方法可以获取元素在过渡中的 每一帧的状态 2D/3D变形 2D变形（transform） transform只能作用于块级元素 旋转 rotate 1 平移 translate 倾斜 skew 缩放 scale 基点的变换 transform-origin : x y ; 矩阵 matrix 旋转 平移 倾斜 缩放 例子：立方体/三棱柱/多棱柱 开机动画 3D变形 景深 perspective 构建3D舞台 让3D场景有近大远小的效果，不可继承，可作用于后代元素 ①perspective：xxx属性，放在包含块内，作用于内部子元素 ②transform：perspective（xxx） 作用元素自身，且必须为transform第一个值；如transform：scale(2) perspective(100px)将没有效果 原理： 景深越大，灭点越远，元素变形更小 景深越小，灭点越近，元素变形更大 perspective-origin 控制视角位置（眼睛的位置）（控制的是X,Y轴），Z轴实际就是perspective控制 景深的叠加 尽量避免景深叠加 transform-style 营造有层级感的3D，不可继承的属性，只作用于子元素（也就是应该设置给父元素） plat perserve-3d backface-visibility 隐藏背面元素， 一个元素有两面，但不意味着有厚度，在一个状态下，元素只能展现自己的一面 3D旋转 rotateX(angle) rotateY(angle) rotateZ(angle) rotate3d(x, y, z, angle) 3D缩放 scaleZ(number) scale3d(x, y, z) 3D平移 translateX() translateY() translateZ() Z不能写百分比 translate3d(x, y, z) CSS3动画 关键帧 12345678- @keyframes name&#123; keyfromes-selector&#123; css-style &#125;- &#125;// keyfromes-selector可以使关键帧from（0%）和to（100%）// 也可以是百分比，代表的是时间的百分比 animation-name 调用@keyframe定义的动画 动画内的属性 animation-duration 动画播放时间，一个动画周期的时长，动画周期是可以循环的 animation-timing-function 作用于一个关键帧周期，而非整个动画周期 steps（num， start/end ） num 拆成多少帧 start 看不见第一帧 end 看不见最后一帧 animation-delay 动画的延迟，动画外的属性 animation-iteration-count 循环关键帧的次数，只会管理动画内的属性，动画的延迟不会被循环 infinite 无限次 number 只作用于动画内的属性 ，重复的是关键帧 animation-direction 定义动画方向（关键帧的方向），还会影响animation-timing-function的形式 animation-direction：reverse 反转的是关键帧和animation-timing-function alternate 奇偶 normal（默认） animation-fill-mode 定义动画开始之前和结束之后的操作 backwards：from之前的状态与from的状态保持一致 forwards： to之后的状态与to保持一致 both： 前面两种的效果 none（默认）：动画的状态保持在动画之前的位置 animation-play-state 管理动画的运行和停止 running pause 布局扩展 flex布局 老版本通常称为box，新版本通常称为flex flex容器 flex项目 主轴、侧轴 由flex-direction/-webkit-box-orient确定 项目永远在主轴的正方向排列 新版flex 容器—主轴及其方向控制： 老版本： -webkit-box-orient : horizontal/vertical 控制主轴是那一根 x轴 / y轴 -webkit-box-direction : normal / reverse 控制主轴方向 正方向 / 反方向 新版本 flex-direction: row→ row-reverse← column↓ column-reverse↑ 容器–项目对齐 老版本 -webkit-box-pack: start end center justify(空间在项目之间) 主轴 -webkit-box-align:start end center justify(空间在项目之间) 侧轴 新版本 justify-content: flex-start flex-end center space-between space-around align-items: flex-start flex-end center baseline strench(等高布局，项目不能设置高度) 弹性空间管理 将主轴上的富裕空间按比例分配到项目的width/height上 老版本：-webkit-box-flex: 0(默认值) 弹性因子 新版本：flex-grow:0(默认值) 弹性因子 新版本新增属性： 容器 flex-wrap:nowrap wrap wrap-reverse 控制侧轴方向 单行还是多行显示 “会影响flex-shrink” align-content: 调整伸缩行/列，将行/列当成整体 flex-flow:\ \ 项目 order 控制项目排列顺序 align-self:控制单个项目 flex-grow:拉伸因子 计算方式： 可用空间 = 容器大小 - 所有相邻项目flex-basis的总和 可扩展空间 = 可用空间 / 所有相邻项目flex-grow的总和 每个项目伸缩大小 = 伸缩空间基准 + （可扩展空间 * flex-grow值） flex-basis: flex-shrink: 1 (默认值) 前提：flex-wrap:nowrap 一行才能使用 计算 计算收缩因子与基准值乘积总和 计算收缩因子 收缩因子 = 项目收缩因子 * 项目基准 / 第一步计算总和 移除空间计算 移除空间 = 项目收缩因数 * 负的溢出空间 响应式布局（媒体查询选择器） @media 媒体类型 all screen print 媒体属性 width 浏览器窗口的尺寸 min-width:800px; 指大于等于800px max-width:800px; 指小于等于800px device-width: 设备独立像素（min max） pc端：分辨率 移动端：具体看机器的参数 device-pixel-ratio：必须加webkit前缀 PC端：1 移动端：看具体参数 orientation：横竖屏 orientation : portrait 竖屏 orientation：landscape 横屏 关键字 and 代表与的意思， 一般用and来连接媒体类型和媒体属性 only 和浏览器兼容性有关， 老版本的浏览器只支持媒体属性，不支持带媒体属性的查询 123@media only screen and (orientation:;andscape)&#123; &#125; , (逗号)：or的意思 not 取反的意思 多列布局]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
</search>
