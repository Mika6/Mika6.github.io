<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[近期找工作的一些反思与计划]]></title>
    <url>%2F2019%2F05%2F20%2F%E8%BF%91%E6%9C%9F%E6%89%BE%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%8D%E6%80%9D%2F</url>
    <content type="text"><![CDATA[摘要：今天是520,不过也不关单身狗什么事[ 泪汪汪 ]。已经是5月20日了，回顾一下近期找工作，这个过程是比较难熬的，同时也是快速成长的一个过程。从存在的问题，学到的东西以及接下来怎么做反思自己，同时也定一下计划。 存在的问题 作为一个非计算机专业的人，计算机基础知识相对薄弱，特别是对数据结构与算法这块，作为一个程序员的内功，需要花时间去仔细研究学习。 前端这一块，自己确实有些着急，看着小伙伴一个个都开始工作了，心里说不急是不可能的。导致学习过程中存在走马观花的时候，以为自己学会了，可过一段时间就忘得一干二净。 学习时候，进度安排的太快，很多知识停留在表面，缺乏深入的学习，应该对底层原理性的东西进行系统的学习。 因为时间比较赶，缺乏动手，这是很不好的习惯，知识只有在使用中才能融会贯通，读书这么多年，又犯这种重复性的问题，需要认真调整。 还有一点也要反思，写的文档，太流水了，缺乏系统性的深入探究。 学到了哪些 思维要放开，遇到问题要举一反三，作为一个前端应该具备一定的产品思维，应该是产品驱动技术 之前看到有句话是这样讲的：当你感到难熬的时候，那就是你成长的时候。这段时间的找工作，确实是每天都在马不停蹄的去发现问题，解决问题，查漏补缺，当也能真切的感受到自己明显在进步。 选择公司的时候一定要想清楚自己想要的是什么样的，之前拒了外包公司，是因为自己觉得他们的产品周期很短，项目很多很杂，而且人员流动很大，我觉得这样的公司很难有技术积累，产品很难做到有深度。同时，一人身兼数职，这对个人的成长也是不好的，我认为专业的人干专业的事，才能所处好的产品。 基础知识是一切的根本，吃透基础知识的点点滴滴，面对一些框架，库也能更加得心应手。 接下来怎么做 首先是要继续找工作，首先要想办法养活自己。 合理安排时间却补学相关计算机基础，多刷算法题。 多看面经查漏补缺，巩固前端基础知识。 对知识点更深入的探究，虽然是个菜鸟，只要花时间去研究，也能写出好的文档的。 造轮子，刷题不能停，这些都是基石。 计划安排5月只剩10天了，希望接下来的面试能收到满意的offer，当然，除了找工作，学习的脚步也不能停下来。就这十天做下规划。 首先要将前两天设计的H5简历尽快做完，并放到线上。2~3天 Promise这块深入研究下，因为有的面试要求手写，自己只是会用，没有深入了解底层实现。 0.5天 vuex需要重新研究研究，一段时间不用，机会快忘了。 0.5天 vue各种情况的组件通信总结出来，并撰写文档，向高质量迈进~ 0.5天 网络基础复习巩固，特别是http,https,TCP相关的内容 0.5天 之前性能优化的文档与面试问题总结的文档还没写完，抽时间总结完。 1天 CSS常见布局需要进行总结，尽可能多的实现方式，不同方式的优缺点，兼容性，使用场景。 1天 每天至少刷一道算法题,每天刷套笔试真题]]></content>
      <categories>
        <category>反思</category>
      </categories>
      <tags>
        <tag>反思</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue路由传参方式]]></title>
    <url>%2F2019%2F05%2F19%2F017-vue%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[摘要：vue 路由传参指的是，嵌套路由时，由父路由向子路由传递参数。传递参数主要有两种方式：query 传参；params 传参。params 传参存在两种形式，一是在 url 中显示参数，而是在 url 中不显示参数。 query 传参方式 定义路由router –&gt; index.js 123456789101112131415161718192021222324// index.jsimport Vue from 'vueimport Router from 'vue-router'import Parent from 'components/parent/parent'import Child from 'components/child/child'Vue.use(Router)export default new Router(&#123; routes:[ &#123; path: '/parent', name: 'parent', component: Parent, children: [ &#123; path: '/parent/child/', name: 'child', component: Child &#125; ] &#125; ]&#125;) 修改父组件中路由导航router-link 用来进行路由导航，router-view 用来进行路由页面渲染&lt;router-link :to=&quot;{path:&#39;/parent/child&#39;,query:{id:001}}&quot;&gt; 1234567&lt;!-- parent.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;router-link :to="&#123;path:'parent/child',query:&#123;id:001&#125;&#125;"&gt;&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 子组件获取参数this.$route.query.id 12345&lt;template&gt; &lt;div class="child"&gt; &lt;span&gt;&#123;&#123;this.$route.query.id&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt; params 传递参数(url 中显示) 定义路由router –&gt; index.js 123456789101112131415161718192021222324// index.jsimport Vue from 'vueimport Router from 'vue-router'import Parent from 'components/parent/parent'import Child from 'components/child/child'Vue.use(Router)export default new Router(&#123; routes:[ &#123; path: '/parent', name: 'parent', component: Parent, children: [ &#123; path: '/parent/child/:id', name: 'child', component: Child &#125; ] &#125; ]&#125;) 父组件修改路由导航&lt;router-link to=&quot;/parent/child/001&quot;&gt; 123456&lt;template&gt; &lt;div&gt; &lt;router-link to="/parent/child/001"&gt;&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 子组件获取参数this.$route.params.id 12345&lt;template&gt; &lt;div class="child"&gt; &lt;span&gt;&#123;&#123;this.$route.params.id&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt; 将参数暴露在 url 中存在安全问题，如 XSS 攻击 params 传递参数(url 中不显示)通过路由的名字 name 来实现 定义路由router –&gt; index.js 123456789101112131415161718192021222324// index.jsimport Vue from 'vueimport Router from 'vue-router'import Parent from 'components/parent/parent'import Child from 'components/child/child'Vue.use(Router)export default new Router(&#123; routes:[ &#123; path: '/parent', name: 'parent', component: Parent, children: [ &#123; path: '/parent/child/', name: 'child', component: Child &#125; ] &#125; ]&#125;) 父组件修改路由导航&lt;router-link to=&quot;/parent/child/001&quot;&gt; 123456&lt;template&gt; &lt;div&gt; &lt;router-link :to="&#123;name:'child',params:&#123;id:001&#125;&#125;"&gt;&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 子组件获取参数this.$route.params.id 12345&lt;template&gt; &lt;div class="child"&gt; &lt;span&gt;&#123;&#123;this.$route.params.id&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt; 不在 url 中显示这种方式，在页面舒心的时候，传递的值会丢失 更多详情参考VUE 官方文档]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现二叉树]]></title>
    <url>%2F2019%2F05%2F15%2FDS-001-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[摘要：二叉树（Binary Search Tree）是一种特殊的树，最多有两个子节点。二叉树的遍历方法有深度遍历和广度遍历，深度遍历有前序、中序和后序遍历三种遍历方法，广度遍历也就是所谓的层次遍历。四中遍历方法的基本思路： 前序遍历：根节点 –&gt; 左子树 –&gt; 右子树 中序遍历：左子树 –&gt; 根节点 –&gt; 右子树 后序遍历：左子树 –&gt; 右子树 –&gt; 根节点 层次遍历：逐层遍历 上图遍历结果如下： 前序遍历：1 2 4 5 7 8 3 6 中序遍历：4 2 7 5 8 1 3 6 后序遍历：4 7 8 5 2 6 3 1 层次遍历：1 2 3 4 5 6 7 8 二叉树的实现1234567891011121314151617181920212223// 定义节点class Node&#123; constructor(value)&#123; this.value = value this.left = null this.right = null &#125;&#125;// 定义树class BSTree&#123; constructor(data)&#123; this.root = null &#125; //二叉树的操作方法 // insert(value)&#123;...&#125; // romove(value)&#123;...&#125; // search(value)&#123;...&#125; // min/max // preOrderTraverse()&#123;...&#125; // inOrderTraverse()&#123;...&#125; // postOrderTraverse()&#123;...&#125;&#125; 插入节点123456789101112131415161718192021222324insert(value)&#123; let newNode = new Node(value) if(!this.root)&#123; this.root = newNode &#125;else&#123; this.insertNode(this.root, newNode) &#125;&#125;// 插入子节点insertNode(node, newNode)&#123; if(newNode.value &lt; node.value)&#123; if(!node.left)&#123; node.left = newNOde &#125;else&#123; this.insertNode(node.left, newNode) &#125; &#125; else &#123; if(!node.right)&#123; node.right = newNode &#125; else &#123; this.insertNode(node.right, newNode) &#125; &#125;&#125; 前序遍历前序遍历先访问节点本身，然后访问左子树，最后访问右子树 1234567891011preOrderTraverse(callback)&#123; this.preOrderTraverseNode(this.root, callback)&#125;preOrderTraverseNode(node, callback)&#123; if(node !== null)&#123; callback(node.value) this.preOrderTraverseNode(node.left) this.preOrderTraverseNode(node.right) &#125;&#125; 中序遍历中序遍历先访问左子树，然后访问节点自身，最后访问右子树 1234567891011inOrderTraverse(callback)&#123; this.inOrderTraverseNode(this.root, callback)&#125;inOrderTraverseNode(node, callback)&#123; if(node !== null)&#123; this.inOrderTraverseNode(node.left, callback) callback(node.value) this.inOrderTraverseNode(node.right, callback) &#125;&#125; 后序遍历123456789postOrderTraverse(callback)&#123; this.postOrderTraverseNode(this.root, callback)&#125;postOrderTraverseNode(node, callback)&#123; this.postOrderTraverseNode(node.left, callback) this.postOrderTraverseNode(node.right, callback) callback(node.value)&#125; 搜索最小/大值123456789101112131415161718192021222324// 搜索最小值min()&#123; return this.nimNode(this.root).value&#125;minNOde(node)&#123; if(!node.left)&#123; return node &#125;else&#123; return this.nimNode(node.left) &#125;&#125;// 搜索最大值max()&#123; return this.maxNode(this.root).value&#125;maxNode(node)&#123; if(!node.right)&#123; return node &#125;else&#123; return this.maxNode(node.right) &#125;&#125; 搜索特定的值12345678910111213141516search(value)&#123; return this.searchNode(this.root, value) &#125;searchNode(node, value)&#123; if(!node)&#123; return false &#125; if(value &lt; node.value)&#123; return this.searchNode(node.left, value) &#125;else if(value &gt; node.value)&#123; return this.searchNode(node.right, value) &#125;else&#123; return true &#125;&#125; 移除节点123456789101112131415161718192021222324252627282930313233343536remove(value)&#123; return this.root = this.removeNode(this.root, value)&#125;removeNode(node, value)&#123; if(!node)&#123; return null &#125; if(value &lt; node.value)&#123; node.left = this.removeNode(node.left, value) return node &#125;else if(value &gt; node.value)&#123; node.right = this.removeNode(node.right, value) return node &#125;else&#123; // 如果不存在左右节点 if(!node.left &amp;&amp; !node.right)&#123; node = null return node &#125; // 存在左节点 if(!node.right)&#123; node = node.left return node // 存在右节点 &#125; else if(!node.left)&#123; node = node.right return node &#125; // 两个节点都存在 let minRight = this.minNode(node.right) node.value = minRight.value node.right = this.removeNode(node.right, minRight.value) return node &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css基础知识小结]]></title>
    <url>%2F2019%2F05%2F13%2F001-css%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[选择器1.1 【基本选择器】 通配符 *{ } 元素选择器 body{ } 类选择器 .list{ } ID选择器 #list{ } 后代选择器 .list li { } 1.2 【基本选择器扩展】 子元素选择器 #wrap&gt;.inner{} 相邻兄弟选择器 #wrap+.inner{ } 通用兄弟选择器 #list~li{ } 选择器分组 h1,h2,h3{ } 1.3 【属性选择器】 存在和值属性选择器 [ attr ] 包含attr的所有元素，不论上attr为何值 [ attr=val ] 选中attr为val的值 [ attr~=val ] 带有以attr命名属性的元素，并且改属性是一个以空格作为分隔符的值列表，其中至少包含一个值为val 子串值属性选择器 [ attr|=val ] 选择attr属性的值是val（包括val）或者以val- 开头的元素 [ attr^=val ] 选择attr属性的值以val开（）头的元素 [ attr$=val ] 选择attr属性的值以val结尾（包括）的元素 [ attr*=val ] 选择attr属性的值包含字符串val的 1.4【 伪类伪元素选择器】 链接伪类 :link 未访问 :visited 访问过 :target 代表一个特殊元素，它的id是URI的片段标识符 【坑】：link visited target 只能作用于链接元素 ：hover ：active 几乎可以作用于所有元素 由于a标签的：link 和 : visited可以覆盖所有的a标签的状态，所以当：link ：visited :hover :active同时 作用于a标签时，：link ：visited不能放在最后 注意：：visited选择器，只有一下属性才能被应用到已访问的链接 color background-color border-color 动态伪类 :hover :active 表单伪类 :enabled 匹配可编辑的表单 :disable 匹配被禁用的表单 :checked 匹配被选中的表单 :focus 匹配获焦的表单 结构伪类 nth-child(index)系列 :first-child :last-child :nth-last-child(index) :only-child 相当于：：first-child :last-child或者:nth-child(1) :nth-last-child(1) nth-of-type(index)系列 :first-of-type :last-of-type :nth-last-of-type(index) :only-of-type 相当于：：first-of-type :last-of-type或者：nth-of-type(1) :nth-last-of-type(1) :not 排除某一个 :empty （内容必须为空，空格都不行，有attr没关系） 伪元素选择器 ::after ::before ::first-letter ::first-line ::selection 1.5 【CSS声明的优先级】 1.5.1 选择器的特殊性 选择器的特殊性由选择器本身的组件确定，特殊性值分为四个部分，如 0,0,0,0 一个选择器的具体特殊性如下确定： 对于选择器中给定的ID属性，加 0,1,0,0 对于选择器中给定的各个类属性，属性选择，或伪类，加 0,0,1,0 对于选择器中的给定的各个元素和伪元素，加 0,0,01 通配符选择器的特殊性为 0,0,0,0 结合符对选择器特殊性没有一点贡献 内联声明的特殊性都是 1,0,0,0 ““ 继承没有特殊性 特殊性 1,0,0,0 大于所有以0开头的特殊性（不进位） 选择器特殊性最终都会授予给其对应的声明 如果多个规则与同一个元素匹配，而且有些声明互相冲突时，特殊性大的占优势 1.5.2 重要声明 有时某个声明比较重要，超过了所有的其他声明，CSS2.1就称之为重要声明 并允许在这些声明的结束分号之前插入 !important 来标志 必须要准确的放置 !important 否则无效， !important 总是要放在声明的最后，即分号前面 标志位!important 的声明比呢没有特殊性的特殊值，但要与非重要声明分开考虑 实际上所有的重要声明会被浏览器分为一组，重要声明的冲突会在其内部解决 非重要声明也会被分为一组，非重要声明的冲突也会在其内部解决 如果一个重要声明与非重要声明冲突，生出的总是重要声明 1.5.3 继承 继承没有特殊性，甚至连0特殊性都没有 0特殊性要比无特殊性来得强 1.5.4 来源 CSS样式来源大致三种 创作人员 — 程序员 读者 — 用户代理 – 浏览器 它们的权重如下： 读者的重要声明 创作人员的重要声明 创作人员的正常声明 读者的正常声明 用户代理的声明 1.5.5 层叠 找出所有相关的规则，这些规则额都包含一个选择器 计算声明优先级： 先按来源排序 再按选择器的特殊性排序 最终排序 自定义字体 @font-face @font-face 允许网页开发者为其网页指定在线字体 1234@font-face&#123; font-family:"fontName"; src:url( );&#125; 字体图标 软件：Ai 画矢量图 FontLab 做字体的 站点： www.fontsequirrel.com icommon.io/app/ 新的UI方案 3.1 文本新样式 文字阴影 text-shadow ：color \ \ \ 为文字添加阴影，可以添加多层，阴影值之间用逗号隔开（多个阴影时，第一个在最上面） 默认值 none 不可继承 color 可选 位置可在偏移量之前或之后 offset-x / offset-y 必选 指定水平/垂直偏移量 blur-radius 可选 length值 默认为0 值越大，模糊半径越大 应用：浮雕文字， 文字模糊 文字描边 文字排版 3.2 盒模型新样式 盒模型阴影 box-shadow 默认值：none 不可继承 inset： 默认阴影在外边框，使用inset后，阴影在内边框 offset-x / offset-y length值 设置阴影偏移量 blur-radius 值越大阴影面积越大 不可为负值 spread-radius 取正值时，阴影放大；取负值时阴影收缩；默认为0 color 指定阴影颜色 倒影 -webkit-box-reflect 设置元素倒影 默认值：none 不可继承 第一个值：倒影方向：above, below, right, left 第二个值：倒影距离 长度单位 第三个值： 渐变 resize- box-sizing 允许你控制一个元素可调整大小性 一定要配合overflow:auto使用 默认值：none both 允许在水平和垂直方向调整大小 horizontal 允许在水平方向上调整大小 vertical 允许在垂直方向上调整元素大小 3.3 新增UI样式 3.3.1 圆角 border-radius 默认值：none 不可继承 border-top-left-radius border-top-right-radius border-bottom-right-radius border-bottom-left-radius 3.3.2 边框图片 border-image：\ || \ [/\] || \ 引入背景图片：border-image-source : url( ) 切割图片：border-image-slice : [\ | \] {1,4} &amp;&amp; fill ? 这里number没有单位，默认就是像素 图片宽度：border-image-width：[\ | \ |\ | auto]{1,4} 排列方式：[strench | repeat | round] {1,2} 3.3.3 背景 CSS2 1.background-color：transparent || \ 2.background-image: none || \ 3.background-repeat: repeat || repeat-x || repeat-y || no-repeat 4.background-position: \ || \ || [left|center|rigt] [,top|center|bottom] 百分比计算是定位区域的尺寸减去背景图片的尺寸 background-attachment: scroll || fixed 设置元素背景图片是否固定或者随页面其余部分滚动 CSS3 1.background-origin：padding-box || border-box || content-box 决定backgroung-image的参考原点 默认情况下背景图片是从padding-box开始绘制，从border-box开始剪裁 2.background-clip: border-box || padding-box || content-box 背景颜色也会剪掉 -webkit-background-clip:text 按文字剪切背景 3.background-size: auto || length || percentage || cover || contain 百分比相对于背景区域 单值时，另一个auto 4.background-break 只支持firefox background 简写 3.3.4 渐变 线性渐变 linear-gradient ([[\ | to \],]?\[,color-stop&gt;]+) 例子 发廊灯/光斑动画 径向渐变 radial-gradient([\ || \ [at \]?, | at \,]?\[,\]+) 改变形状：shape circle（圆） ellipse（椭圆） 渐变形状的大小 size closest-side 离圆心最近的边 closest-corner 距离圆心最近的角 farthest-side 离圆心最远的边 farthest-corner 离圆心最远的角 改变圆心的位置 position 默认值为center 过渡 transition-property: none | all | property transition-duration:\[,\]* 一定要带单位，如果不带单位，多个时间的时候，会使其他失效 如 1s, 0, 3s transition-timing-function: ease (先快后慢) linear 匀速 ease-in 加速 ease-out 减速 ease-in-out 先加速再减速 cubic-bezier(p0, p1, p2, p3) transition-delay:\ 延时 注意： 1.transition在元素首次渲染还没有结束的情况下，是不会被触发的 2.在绝大部分变换样式切换时，如果变换函数的位置个数不同也不会触发过渡 3.过渡只关心元素的初始状态和结束状态，没有方法可以获取元素在过渡中的 每一帧的状态 2D/3D变形 2D变形（transform） transform只能作用于块级元素 旋转 rotate 1 平移 translate 倾斜 skew 缩放 scale 基点的变换 transform-origin : x y ; 矩阵 matrix 旋转 平移 倾斜 缩放 例子：立方体/三棱柱/多棱柱 开机动画 3D变形 景深 perspective 构建3D舞台 让3D场景有近大远小的效果，不可继承，可作用于后代元素 ①perspective：xxx属性，放在包含块内，作用于内部子元素 ②transform：perspective（xxx） 作用元素自身，且必须为transform第一个值；如transform：scale(2) perspective(100px)将没有效果 原理： 景深越大，灭点越远，元素变形更小 景深越小，灭点越近，元素变形更大 perspective-origin 控制视角位置（眼睛的位置）（控制的是X,Y轴），Z轴实际就是perspective控制 景深的叠加 尽量避免景深叠加 transform-style 营造有层级感的3D，不可继承的属性，只作用于子元素（也就是应该设置给父元素） plat perserve-3d backface-visibility 隐藏背面元素， 一个元素有两面，但不意味着有厚度，在一个状态下，元素只能展现自己的一面 3D旋转 rotateX(angle) rotateY(angle) rotateZ(angle) rotate3d(x, y, z, angle) 3D缩放 scaleZ(number) scale3d(x, y, z) 3D平移 translateX() translateY() translateZ() Z不能写百分比 translate3d(x, y, z) CSS3动画 关键帧 12345678- @keyframes name&#123; keyfromes-selector&#123; css-style &#125;- &#125;// keyfromes-selector可以使关键帧from（0%）和to（100%）// 也可以是百分比，代表的是时间的百分比 animation-name 调用@keyframe定义的动画 动画内的属性 animation-duration 动画播放时间，一个动画周期的时长，动画周期是可以循环的 animation-timing-function 作用于一个关键帧周期，而非整个动画周期 steps（num， start/end ） num 拆成多少帧 start 看不见第一帧 end 看不见最后一帧 animation-delay 动画的延迟，动画外的属性 animation-iteration-count 循环关键帧的次数，只会管理动画内的属性，动画的延迟不会被循环 infinite 无限次 number 只作用于动画内的属性 ，重复的是关键帧 animation-direction 定义动画方向（关键帧的方向），还会影响animation-timing-function的形式 animation-direction：reverse 反转的是关键帧和animation-timing-function alternate 奇偶 normal（默认） animation-fill-mode 定义动画开始之前和结束之后的操作 backwards：from之前的状态与from的状态保持一致 forwards： to之后的状态与to保持一致 both： 前面两种的效果 none（默认）：动画的状态保持在动画之前的位置 animation-play-state 管理动画的运行和停止 running pause 布局扩展 flex布局 老版本通常称为box，新版本通常称为flex flex容器 flex项目 主轴、侧轴 由flex-direction/-webkit-box-orient确定 项目永远在主轴的正方向排列 新版flex 容器—主轴及其方向控制： 老版本： -webkit-box-orient : horizontal/vertical 控制主轴是那一根 x轴 / y轴 -webkit-box-direction : normal / reverse 控制主轴方向 正方向 / 反方向 新版本 flex-direction: row→ row-reverse← column↓ column-reverse↑ 容器–项目对齐 老版本 -webkit-box-pack: start end center justify(空间在项目之间) 主轴 -webkit-box-align:start end center justify(空间在项目之间) 侧轴 新版本 justify-content: flex-start flex-end center space-between space-around align-items: flex-start flex-end center baseline strench(等高布局，项目不能设置高度) 弹性空间管理 将主轴上的富裕空间按比例分配到项目的width/height上 老版本：-webkit-box-flex: 0(默认值) 弹性因子 新版本：flex-grow:0(默认值) 弹性因子 新版本新增属性： 容器 flex-wrap:nowrap wrap wrap-reverse 控制侧轴方向 单行还是多行显示 “会影响flex-shrink” align-content: 调整伸缩行/列，将行/列当成整体 flex-flow:\ \ 项目 order 控制项目排列顺序 align-self:控制单个项目 flex-grow:拉伸因子 计算方式： 可用空间 = 容器大小 - 所有相邻项目flex-basis的总和 可扩展空间 = 可用空间 / 所有相邻项目flex-grow的总和 每个项目伸缩大小 = 伸缩空间基准 + （可扩展空间 * flex-grow值） flex-basis: flex-shrink: 1 (默认值) 前提：flex-wrap:nowrap 一行才能使用 计算 计算收缩因子与基准值乘积总和 计算收缩因子 收缩因子 = 项目收缩因子 * 项目基准 / 第一步计算总和 移除空间计算 移除空间 = 项目收缩因数 * 负的溢出空间 响应式布局（媒体查询选择器） @media 媒体类型 all screen print 媒体属性 width 浏览器窗口的尺寸 min-width:800px; 指大于等于800px max-width:800px; 指小于等于800px device-width: 设备独立像素（min max） pc端：分辨率 移动端：具体看机器的参数 device-pixel-ratio：必须加webkit前缀 PC端：1 移动端：看具体参数 orientation：横竖屏 orientation : portrait 竖屏 orientation：landscape 横屏 关键字 and 代表与的意思， 一般用and来连接媒体类型和媒体属性 only 和浏览器兼容性有关， 老版本的浏览器只支持媒体属性，不支持带媒体属性的查询 123@media only screen and (orientation:;andscape)&#123; &#125; , (逗号)：or的意思 not 取反的意思 多列布局]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些兼容性问题整理]]></title>
    <url>%2F2019%2F05%2F09%2F%E5%9D%91-003-%E4%B8%80%E4%BA%9B%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[div 中插入 img 存在间隙原因: display:inline-block 布局的元素在 chrome 下会出现几像素的间隙，原因是因为我们在编辑器里写代码的时候，同级别的标签不写在同一 行以保持代码的整齐可读性，即 inline-block 布局的元素在编辑器里不在同一行，即存在换行符，因此这就是著名的 inline-block“换行 符/空格间隙问题”。如果 inline-block 元素间有空格或是换行产生了间隙，那是正常的，应该的。如果没有空格与间隙才是不正常的（IE6/7 block 水平元素）。IE8+才会出现。处理： img 标签的 display 属性设置为 block： 123img&#123; display: block;&#125; 把 div 的 font-size 设置为 0： 123div &#123; font-size: 0;&#125; 设置 img 标签的 vertical-align 属性： 12345img &#123; vertical-align: top; vertical-align: middle; vertical-align: bottom;&#125; a 标签的 CSS 状态的顺序有时候在写a标签的样式，发现样式没有效果，或者点击之后，hover、active样式没有效果，原因：样式被覆盖了正确的顺序： link:平常状态 visited: 访问之后的状态 hover: 鼠标放到链接之上 active: 链接被点击时 IE6 双倍边距问题设置ie6中设置浮动，同时又设置margin，会出现双倍边距的问题解决：转换为行内元素 1display: inline; IE9 以下 opacity 属性失效解决：在 IE8 及其更早的浏览器下，我们可以使用 filter 属性，来代替 opacity 属性，从而达到 IE8 下设置元素透明度目的 1234div &#123; opacity: 0.8; filter: alpha(opacity=80);&#125; IE6 不支持 min-height/width 属性问题在改变浏览器窗口大小的时候，我们需要让窗口改变到一定程度，网页款古典就不会减小，出现滚动条，通过 min-width 属性很容易实现，但 IE6 不支持该属性解决：使用 IE6 本身的 BUG，当块级元素内部的东西超出此块级元素的高度时，块级元素的高度会被撑开，也就是说 IE6 中的 height 属性本身就等同于 min-height。 12min-width: 980px;_min-height: 980px;]]></content>
      <categories>
        <category>坑</category>
      </categories>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试问题小结]]></title>
    <url>%2F2019%2F05%2F09%2F016-%E8%BF%91%E6%9C%9F%E9%9D%A2%E8%AF%95%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[整理一些面试过程中的问题 JS 相关闭包闭包值有权访问另一个函数作用域中变量的函数，创建的创建方式是在一个函数的内部创建另一个函数，并在作用于外被调用。主要有三点需要注意：1 访问所在作用域的变量；2 函数嵌套；3 在所在作用域外被调用。注：如果定义了嵌套函数，每个嵌套的函数都格子对应一个作用域链，并且这个作用域链指向一个变量绑定对象（被访问变量所在作用域的活动对象），如果这些嵌套的函数对象在外部函数中保存下了，那么它将会和所指向的变量绑定对象一样被回收。如果这个函数定义了嵌套函数，并将它作为返回值返回或者存储在某处的属性中，这是就会有一个外部引用指向这个潜逃的函数。他就不会被当做垃圾回收，并且塔索指向的变量绑定对象也不会被回收。 JS 数据类型原始类型： Number String Boolean Null Undefined Symbol(ES6) 引用类型： Object undefined 与 null 的区别undefined 与 null 都是 JS 的原始类型， null 转换为数值为 0，undefined 转换为数值为 NaN undefined 和 null 与其他类型的值比较时，结果都为 false，它们互相比较时结果为 true。 undefined 当声明的变量还未被初始化时，变量的默认值为 undefined 调用函数时，应该提供的参数没提供，则该参数为 undefined 函数没有返回值时，默认返回 undefined 对象没有赋值的属性 null null 表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象 作为函数的参数，表示参数不是对象 作为对象原型链的终点( Object.getPrototypeOf(Object.prototype) ) 1234567typeof undefined; //undefinedtypeof null; // objectnull == undefined; //truenull === undefined; // false cookie &amp; localStorage &amp; sessionStorage cookie 是服务器与客户端状态保持的一种解决方案，主要用于存储回话数据，cookie 的大小与数量是由限制的，不同浏览器不一样，一般在 4K 左右。cookie 受同源策略的影响，但同一个一级域是可共享的（借此可实现单点登录）。 localStorage 与 sessionStorage 都是 HTML5 中 Web Storage 规范包含的两种对象。 1.两者都是本地存储，不与服务器进行交互通信。2.localStorage 的生命周期是永久的，只要不主动删除就一直存储在本地的硬件设备上，sessionStorage 只在当前会话下有效，sessionStorage 在同源窗口一直存在，即使刷新或者进入同源的另一页面，数据任然存在，但是关闭浏览器窗口后就会销毁。 3.两者的大小都在 2.5~10MB。 4.两者都只能存储字符串类型，复杂对象可用 JSON 对象的 stringify 和 parse 进行处理。 5.获取：window.localStorage / window.sessionStorage 6.应用： localStorage 常用于长期登录(判断用户是否登录)；sessionStorage 敏感账号一次性登录。 事件流事件流分三个阶段： 事件捕获阶段 处于目标阶段 事件冒泡阶段 IE9+才支持事件捕获 事件委托事件委托利用了事件冒泡，只需中鼎一个事件处理程序，就可以管理某一类型的所有事件，做法是，将事件绑定到祖先元素上，利用后代元素冒泡触发事件。解决的问题： 性能的优化 1.每个事件处理函数都是对象，都要占用内存，内存中的对象越多，性能就越差； 2.减少了 DOM 操作的次数，提高了页面交互就绪时间。 解决了新添加元素时间绑定的问题。 图片懒加载 this 指向 js 异步加载方法 节流与防抖函数 一行代码随机打乱数组 跨域问题 setTimeout &amp; setInterval &amp; requestAnimation js 深浅拷贝 15 HTML &amp; CSS 清楚浮动 怎么上下左右居中 flex 布局 BFC 超出文本省略 边距重叠问题 媒体查询@media 盒模型 VUE vue 的生命周期 vue-router 怎么配置路由 MVC 与 MVVM 区别 原理 vue 组建中 style 加 scoped 与不加有什么不一样 vuex 能否用来存储数据 jQuery 与 vue 有哪些不同 v-if 与 v-show 的区别 keep-alive 性能优化 前端开发性能优化方法 网站性能优化方法 网络基础 TCP 三次握手与四次挥手 http 缓存机制 TCP 与 DUP 区别 get 与 post 请求的区别 http 与 https 浏览器相关 浏览器渲染机制 浏览器缓存 怎么获取查询参数 回流 &amp; 重绘 其他 前端数据可视化有哪些框架或库 小程序框架]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】前端自检清单]]></title>
    <url>%2F2019%2F05%2F09%2F015-%E3%80%90%E8%BD%AC%E3%80%91%E5%89%8D%E7%AB%AF%E8%87%AA%E6%A3%80%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[摘要：掘金上看到一位前辈总结的自检清单，感觉总结的很全面，收藏起来，方便查漏补缺。作者：ConardLi原文链接来源：掘金 开篇前端开发是一个非常特殊的行业，它的历史实际上不是很长，但是知识之繁杂，技术迭代速度之快是其他技术所不能比拟的。winter 在他的《重学前端》课程中提到： 到现在为止，前端工程师已经成为研发体系中的重要岗位之一。可是，与此相对的是，我发现极少或者几乎没有大学的计算机专业愿意开设前端课程，更没有系统性的教学方案出现。大部分前端工程师的知识，其实都是来自于实践和工作中零散的学习。 这样是一个非常真实的现状，实际上很多前端开发者都是自学甚至转行过来的，前端入门简单，学习了几个 API 以后上手做项目也很简单，但是这往往成为了限制自身发展的瓶颈。只是停留在会用阶段是远远不够的，我们还需要不断探索和深入。现在市面上并不缺少学习教程，技术文章，如果盲目的学习你会发现看过以后的知识留存率会很低，而且发现没有了解到的知识越来越多，这会让人产生焦虑。实际上，除了坚持学习的强大的自驱力，你还需要一个很简单的学习方法。那就是：建立自己的知识体系。它能帮助你更系统性的学习，同时你也时刻能知道自己哪些地方是不足的。我会把我工作和学习中接触到的知识全部归纳到我的知识体系中，其中不仅仅包括我已经学过的，还有很多我没有来得及学习的。这不仅仅是我的知识体系，更是我时刻提醒自己的自检清单。下面我会把我的自检清单分享给大家，你可以按照清单上的知识检测自己还有哪些不足和提升，我也建议大家建自己的知识体系，这样工作或者学习甚至面试时，你能快速定位到知识清单中的点，如果你有哪些我没归纳到的点，欢迎在评论区告诉我。 一、JavaScript 基础前端工程师吃饭的家伙，深度、广度一样都不能差。 变量和类型1.JavaScript 规定了几种语言类型 2.JavaScript 对象的底层数据结构是什么 3.Symbol 类型在实际开发中的应用、可手动实现一个简单的 Symbol 4.JavaScript 中的变量在内存中的具体存储形式 5.基本类型对应的内置对象，以及他们之间的装箱拆箱操作 6.理解值类型和引用类型 7.null 和 undefined 的区别 8.至少可以说出三种判断 JavaScript 数据类型的方式，以及他们的优缺点，如何准确的判断数组类型 9.可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用 10.出现小数精度丢失的原因，JavaScript 可以存储的最大数字、最大安全数字，JavaScript 处理大数字的方法、避免精度丢失的方法 原型和原型链1.理解原型设计模式以及 JavaScript 中的原型规则 2.instanceof 的底层实现原理，手动实现一个 instanceof 4.实现继承的几种方式以及他们的优缺点 5.至少说出一种开源项目(如 Node)中应用原型继承的案例 6.可以描述 new 一个对象的详细过程，手动实现一个 new 操作符 7.理解 es6 class 构造以及继承的底层实现原理 作用域和闭包1.理解词法作用域和动态作用域 2.理解 JavaScript 的作用域和作用域链 3.理解 JavaScript 的执行上下文栈，可以应用堆栈信息快速定位问题 4.this 的原理以及几种不同使用场景的取值 5.闭包的实现原理和作用，可以列举几个开发中闭包的实际应用 6.理解堆栈溢出和内存泄漏的原理，如何防止 7.如何处理循环的异步操作 8.理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理 执行机制1.为何 try 里面放 return，finally 还会执行，理解其内部机制 2.JavaScript 如何实现异步编程，可以详细描述 EventLoop 机制 3.宏任务和微任务分别有哪些 4.可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法 5.使用 Promise 实现串行 6.Node 与浏览器 EventLoop 的差异 7.如何在保证页面运行流畅的情况下处理海量数据 语法和 API1.理解 ECMAScript 和 JavaScript 的关系 2.熟练运用 es5、es6 提供的语法规范， 3.熟练掌握 JavaScript 提供的全局对象（例如 Date、Math）、全局函数（例如 decodeURI、isNaN）、全局属性（例如 Infinity、undefined） 4.熟练应用 map、reduce、filter 等高阶函数解决问题 5.setInterval 需要注意的点，使用 settimeout 实现 setInterval 6.JavaScript 提供的正则表达式 API、可以使用正则表达式（邮箱校验、URL 解析、去重等）解决常见问题 7.JavaScript 异常处理的方式，统一的异常处理方案 二、HTML 和 CSSHTML1.从规范的角度理解 HTML，从分类和语义的角度使用标签 2.常用页面标签的默认样式、自带属性、不同浏览器的差异、处理浏览器兼容问题的方式 3.元信息类标签(head、title、meta)的使用目的和配置方法 4.HTML5 离线缓存原理 5.可以使用 Canvas API、SVG 等绘制高性能的动画 CSS1.CSS 盒模型，在不同浏览器的差异 2.CSS 所有选择器及其优先级、使用场景，哪些可以继承，如何运用 at 规则 3.CSS 伪类和伪元素有哪些，它们的区别和实际应用 4.HTML 文档流的排版规则，CSS 几种定位的规则、定位参照物、对文档流的影响，如何选择最好的定位方式，雪碧图实现原理 5.水平垂直居中的方案、可以实现 6 种以上并对比它们的优缺点 6.BFC 实现原理，可以解决的问题，如何创建 BFC 7.可使用 CSS 函数复用代码，实现特殊效果 8.PostCSS、Sass、Less 的异同，以及使用配置，至少掌握一种 9.CSS 模块化方案、如何配置按需加载、如何防止 CSS 阻塞渲染 10.熟练使用 CSS 实现常见动画，如渐变、移动、旋转、缩放等等 11.CSS 浏览器兼容性写法，了解不同 API 在不同浏览器下的兼容性情况 12.掌握一套完整的响应式布局方案 手写1.手写图片瀑布流效果 2.使用 CSS 绘制几何图形（圆形、三角形、扇形、菱形等） 3.使用纯 CSS 实现曲线运动（贝塞尔曲线） 4.实现常用布局（三栏、圣杯、双飞翼、吸顶），可是说出多种方式并理解其优缺点 三、计算机基础关于编译原理，不需要理解非常深入，但是最基本的原理和概念一定要懂，这对于学习一门编程语言非常重要 编译原理1.理解代码到底是什么，计算机如何将代码转换为可以运行的目标程序 2.正则表达式的匹配原理和性能优化 3.如何将 JavaScript 代码解析成抽象语法树(AST) 4.base64 的编码原理 5.几种进制的相互转换计算方法，在 JavaScript 中如何表示和转换 网络协议1.理解什么是协议，了解 TCP/IP 网络协议族的构成，每层协议在应用程序中发挥的作用 2.三次握手和四次挥手详细原理，为什么要使用这种机制 3.有哪些协议是可靠，TCP 有哪些手段保证可靠交付 4.DNS 的作用、DNS 解析的详细过程，DNS 优化原理 5.CDN 的作用和原理 6.HTTP 请求报文和响应报文的具体组成，能理解常见请求头的含义，有几种请求方式，区别是什么 7.HTTP 所有状态码的具体含义，看到异常状态码能快速定位问题 8.HTTP1.1、HTTP2.0 带来的改变 9.HTTPS 的加密原理，如何开启 HTTPS，如何劫持 HTTPS 请求 10.理解 WebSocket 协议的底层原理、与 HTTP 的区别 设计模式1.熟练使用前端常用的设计模式编写代码，如单例模式、装饰器模式、代理模式等 2.发布订阅模式和观察者模式的异同以及实际应用 3.可以说出几种设计模式在开发中的实际应用，理解框架源码中对设计模式的应用 四、数据结构和算法据我了解的大部分前端对这部分知识有些欠缺，甚至抵触，但是，如果突破更高的天花板，这部分知识是必不可少的，而且我亲身经历——非常有用！ JavaScript 编码能力1.多种方式实现数组去重、扁平化、对比优缺点 2.多种方式实现深拷贝、对比优缺点 3.手写函数柯里化工具函数、并理解其应用场景和优势 4.手写防抖和节流工具函数、并理解其内部原理和应用场景 5.实现一个 sleep 函数 手动实现前端轮子1.手动实现 call、apply、bind 2.手动实现符合 Promise/A+规范的 Promise、手动实现 async await 3.手写一个 EventEmitter 实现事件发布、订阅 4.可以说出两种实现双向绑定的方案、可以手动实现 5.手写 JSON.stringify、JSON.parse 6.手写一个模版引擎，并能解释其中原理 7.手写懒加载、下拉刷新、上拉加载、预加载等效果 数据结构1.理解常见数据结构的特点，以及他们在不同场景下使用的优缺点 2.理解数组、字符串的存储原理，并熟练应用他们解决问题 3.理解二叉树、栈、队列、哈希表的基本结构和特点，并可以应用它解决问题 4.了解图、堆的基本结构和使用场景 算法1.可计算一个算法的时间复杂度和空间复杂度，可估计业务逻辑代码的耗时和内存消耗 2.至少理解五种排序算法的实现原理、应用场景、优缺点，可快速说出时间、空间复杂度 3.了解递归和循环的优缺点、应用场景、并可在开发中熟练应用 4.可应用回溯算法、贪心算法、分治算法、动态规划等解决复杂问题 5.前端处理海量数据的算法方案 五、运行环境我们需要理清语言和环境的关系： ECMAScript 描述了 JavaScript 语言的语法和基本对象规范 浏览器作为 JavaScript 的一种运行环境，为它提供了：文档对象模型（DOM），描述处理网页内容的方法和接口、浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口 Node 也是 JavaScript 的一种运行环境，为它提供了操作 I/O、网络等 API 浏览器 API1.浏览器提供的符合 W3C 标准的 DOM 操作 API、浏览器差异、兼容性 2.浏览器提供的浏览器对象模型 (BOM)提供的所有全局 API、浏览器差异、兼容性 3.大量 DOM 操作、海量数据的性能优化(合并操作、Diff、requestAnimationFrame 等) 4.浏览器海量数据存储、操作性能优化 5.DOM 事件流的具体实现机制、不同浏览器的差异、事件代理 6.前端发起网络请求的几种方式及其底层实现、可以手写原生 ajax、fetch、可以熟练使用第三方库 7.浏览器的同源策略，如何避免同源策略，几种方式的异同点以及如何选型 8.浏览器提供的几种存储机制、优缺点、开发中正确的选择 9.浏览器跨标签通信 浏览器原理1.各浏览器使用的 JavaScript 引擎以及它们的异同点、如何在代码中进行区分 2.请求数据到请求结束与服务器进行了几次交互 3.可详细描述浏览器从输入 URL 到页面展现的详细过程 4.浏览器解析 HTML 代码的原理，以及构建 DOM 树的流程 5.浏览器如何解析 CSS 规则，并将其应用到 DOM 树上 6.浏览器如何将解析好的带有样式的 DOM 树进行绘制 7.浏览器的运行机制，如何配置资源异步同步加载 8.浏览器回流与重绘的底层原理，引发原因，如何有效避免 9.浏览器的垃圾回收机制，如何避免内存泄漏 10.浏览器采用的缓存方案，如何选择和控制合适的缓存方案 Node1.理解 Node 在应用程序中的作用，可以使用 Node 搭建前端运行环境、使用 Node 操作文件、操作数据库等等 2.掌握一种 Node 开发框架，如 Express，Express 和 Koa 的区别 3.熟练使用 Node 提供的 API 如 Path、Http、Child Process 等并理解其实现原理 4.Node 的底层运行原理、和浏览器的异同 5.Node 事件驱动、非阻塞机制的实现原理 六、框架和类库轮子层出不穷，从原理上理解才是正道 TypeScript 1.理解泛型、接口等面向对象的相关概念，TypeScript 对面向对象理念的实现 2.理解使用 TypeScript 的好处，掌握 TypeScript 基础语法 3.TypeScript 的规则检测原理 4.可以在 React、Vue 等框架中使用 TypeScript 进行开发 React1.React 和 vue 选型和优缺点、核心架构的区别 2.React 中 setState 的执行机制，如何有效的管理状态 3.React 的事件底层实现机制 4.React 的虚拟 DOM 和 Diff 算法的内部实现 5.React 的 Fiber 工作原理，解决了什么问题 6.React Router 和 Vue Router 的底层实现原理、动态加载实现原理 7.可熟练应用 React API、生命周期等，可应用 HOC、render props、Hooks 等高阶用法解决问题 8.基于 React 的特性和原理，可以手动实现一个简单的 React Vue1.熟练使用 Vue 的 API、生命周期、钩子函数 2.MVVM 框架设计理念 3.Vue 双向绑定实现原理、Diff 算法的内部实现 4.Vue 的事件机制 5.从 template 转换成真实 DOM 的实现机制 多端开发1.单页面应用（SPA）的原理和优缺点，掌握一种快速开发 SPA 的方案 2.理解 Viewport、em、rem 的原理和用法，分辨率、px、ppi、dpi、dp 的区别和实际应用 3.移动端页面适配解决方案、不同机型适配方案 4.掌握一种 JavaScript 移动客户端开发技术，如 React Native：可以搭建 React Native 开发环境，熟练进行开发，可理解 React Native 的运作原理，不同端适配 5.掌握一种 JavaScript PC 客户端开发技术，如 Electron：可搭建 Electron 开发环境，熟练进行开发，可理解 Electron 的运作原理 6.掌握一种小程序开发框架或原生小程序开发 7.理解多端框架的内部实现原理，至少了解一个多端框架的使用 数据流管理1.掌握 React 和 Vue 传统的跨组件通信方案，对比采用数据流管理框架的异同 2.熟练使用 Redux 管理数据流，并理解其实现原理，中间件实现原理 3.熟练使用 Mobx 管理数据流，并理解其实现原理，相比 Redux 有什么优势 4.熟练使用 Vuex 管理数据流，并理解其实现原理 5.以上数据流方案的异同和优缺点，不情况下的技术选型 实用库1.至少掌握一种 UI 组件框架，如 antd design，理解其设计理念、底层实现 2.掌握一种图表绘制框架，如 Echart，理解其设计理念、底层实现，可以自己实现图表 3.掌握一种 GIS 开发框架，如百度地图 API 4.掌握一种可视化开发框架，如 Three.js、D3 5.工具函数库，如 lodash、underscore、moment 等，理解使用的工具类或工具函数的具体实现原理 开发和调试1.熟练使用各浏览器提供的调试工具 2.熟练使用一种代理工具实现请求代理、抓包，如 charls 3.可以使用 Android、IOS 模拟器进行调试，并掌握一种真机调试方案 4.了解 Vue、React 等框架调试工具的使用 七、前端工程前端工程化：以工程化方法和工具提高开发生产效率、降低维护难度 项目构建1.理解 npm、yarn 依赖包管理的原理，两者的区别 2.可以使用 npm 运行自定义脚本 3.理解 Babel、ESLint、webpack 等工具在项目中承担的作用 4.ESLint 规则检测原理，常用的 ESLint 配置 5.Babel 的核心原理，可以自己编写一个 Babel 插件 6.可以配置一种前端代码兼容方案，如 Polyfill 7.Webpack 的编译原理、构建流程、热更新原理，chunk、bundle 和 module 的区别和应用 8.可熟练配置已有的 loaders 和 plugins 解决问题，可以自己编写 loaders 和 plugins nginx1.正向代理与反向代理的特点和实例 2.可手动搭建一个简单的 nginx 服务器、 3.熟练应用常用的 nginx 内置变量，掌握常用的匹配规则写法 4.可以用 nginx 实现请求过滤、配置 gzip、负载均衡等，并能解释其内部原理 开发提速1.熟练掌握一种接口管理、接口 mock 工具的使用，如 yapi 2.掌握一种高效的日志埋点方案，可快速使用日志查询工具定位线上问题 3.理解 TDD 与 BDD 模式，至少会使用一种前端单元测试框架 版本控制1.理解 Git 的核心原理、工作流程、和 SVN 的区别 2.熟练使用常规的 Git 命令、git rebase、git stash 等进阶命令 3.可以快速解决线上分支回滚、线上分支错误合并等复杂问题 持续集成1.理解 CI/CD 技术的意义，至少熟练掌握一种 CI/CD 工具的使用，如 Jenkins 2.可以独自完成架构设计、技术选型、环境搭建、全流程开发、部署上线等一套完整的开发流程（包括 Web 应用、移动客户端应用、PC 客户端应用、小程序、H5 等等） 八、项目和业务后端技能1.了解后端的开发方式，在应用程序中的作用，至少会使用一种后端语言 2.掌握数据最终在数据库中是如何落地存储的，能看懂表结构设计、表之间的关联，至少会使用一种数据库 性能优化1.了解前端性能衡量指标、性能监控要点，掌握一种前端性能监控方案 2.了解常见的 Web、App 性能优化方案 3.SEO 排名规则、SEO 优化方案、前后端分离的 SEO 4.SSR 实现方案、优缺点、及其性能优化 5.Webpack 的性能优化方案 6.Canvas 性能优化方案 7.React、Vue 等框架使用性能优化方案 前端安全1.XSS 攻击的原理、分类、具体案例，前端如何防御 2.CSRF 攻击的原理、具体案例，前端如何防御 3.HTTP 劫持、页面劫持的原理、防御措施 业务相关1.能理解所开发项目的整体业务形态、业务目标、业务架构，可以快速定位线上业务问题 2.能理解所开发项目整体的技术架构、能快读的根据新需求进行开发规划、能快速根据业务报警、线上日志等定位并解决线上技术问题 3.可以将自己的想法或新技术在业务中落地实践，尽量在团队中拥有一定的不可替代性 九、学习提升vczh 大神在知乎问题【如何能以后达到温赵轮三位大神的水平？】下的回答：这十几年我一共做了三件事： 1、不以赚钱为目的选择学习的内容；2、以自己是否能造出轮子来衡量学习的效果；3、坚持每天写自己的代码，前 10 年每天至少 6 个小时，不包含学习和工作的时间。 上面几点可能有点难，第一点我就做不到，但是做到下面绩点还是比较容易的。 关于写博客说明下，能给别人讲明白的知识会比自己学习掌握的要深刻许多 1.拥有自己的技术博客，或者在一些博客平台上拥有自己的专栏 2.定期的将知识进行总结，不断完善自己的知识体系 3.尽量将自己的知识转换成真实的产出，不要仅仅停留在书面理解层面，更重要的是实际应用 4.坚持输出自己的代码，不要盲目的扎进公司业 十、技术之外这部分可能比上面九条加起来重要！ 1.了解互联网人员术语：CEO、CTO、COO、CFO、PM、QA、UI、FE、DEV、DBA、OPS 等 2.了解互联网行业术语：B2B、B2C、C2C、O2O 等 3.掌握互联网行业沟通、问答、学习的 4.有一定的”PPT”能力 5.有一定的理财意识，至少了解储蓄、货币基金、保险、指数基金、股票等基本的理财知识 6.掌握在繁重的工作和长期的电脑辐射的情况下保持健康的方法，建立正确的养生知识体系 十一、资源推荐有了知识体系，在阅读一篇技术文章的时候就很容易把它归类，我一直以来就是这样做的。事实证明，在阅读文章或书籍时，有目的和归类的阅读比”随便看看”后的只是留存率要高很多。每阅读到一篇好的文章或者书籍，我都会收藏并归类到我的知识体系中。下面是一些我觉得还不错的文章、博客或者书籍教程等等，分享给大家，资源不多，但都是精品。学习一门知识，最好先阅读官方文档，把所有的 API 大概浏览一遍，再继续看大佬们总结的进阶知识，什么东西是搬运过来的，什么是干货，一目了然。语言基础 [📚]JavaScript 高级程序设计（必看）：book.douban.com/subject/105… [📚]高性能 JavaScript：book.douban.com/subject/536… 现代 JavaScript 教程：zh.javascript.info/ 阮一峰的 ECMAScript 6 教程：es6.ruanyifeng.com/ ECMAScript 6 标准：www.ecma-international.org/ecma-262/6.… HTML meta 标签总结与属性使用介绍：segmentfault.com/a/119000000… CSS 编码指导：github.com/chadluo/CSS… 计算机基础大前端开发者需要了解的基础编译原理和语言知识：fullstack.blog/2017/06/24/… 图解 HTTP：book.douban.com/subject/258… [📚]JavaScript 设计模式与开发实践：book.douban.com/subject/263… 正则表达式 30 分钟入门教程：link.juejin.im/?target=htt… 数据结构和算法数据结构与算法之美：time.geekbang.org/column/intr… 用动画的形式呈现解 LeetCode 题目的思路：github.com/MisterBooo/… JavaScript 数据结构和算法：github.com/ConardLi/aw… 30-seconds-of-code（里面有很多 js 代码非常巧妙，我正在将它翻译成中文）：github.com/ConardLi/30… 运行环境《重学前端》中的浏览器原理章节：time.geekbang.org/column/arti… 图解浏览器的基本工作原理：zhuanlan.zhihu.com/p/47407398 七天学会 NodeJS：github.com/nqdeng/7-da… Node.js 模块加载与运行原理：efe.baidu.com/blog/nodejs… 框架和类库TypeScript Handbook：zhongsp.gitbooks.io/typescript-… React.js 小书：huziketang.mangojuice.top/books/react… React 深入系列：juejin.im/post/5cad39… Webpack React 小书：fakefish.github.io/react-webpa… Vue.js 技术揭秘：github.com/ustbhuangyi… Vuex-在 Vue 中管理状态：sabe.io/tutorials/g… 你需要 Mobx 还是 Redux？：juejin.im/post/5a7fd7… Underscore 源码分析：yoyoyohamapi.gitbooks.io/undersercor… 微信小程序开发资源汇总：github.com/justjavac/a… 腾讯移动 Web 前端知识库：github.com/AlloyTeam/M… 前端工程一口（很长的）气了解 babel：zhuanlan.zhihu.com/p/43249121 Webpack 傻瓜式指南：zhuanlan.zhihu.com/p/20367175 Webpack 原理：segmentfault.com/a/119000001… 廖雪峰的 git 教程：www.liaoxuefeng.com/wiki/001373… 图解 Git：marklodato.github.io/visual-git-… 前端开发者必备的 Nginx 知识：juejin.im/post/5c85a6… 使用 Jenkins 进行持续集成：www.liaoxuefeng.com/article/001… 项目和业务常见六大 Web 安全攻防解析：github.com/ljianshu/Bl… 深入理解前端性能监控：juejin.im/post/5caaac… [📚]高性能网站建设指南：book.douban.com/subject/313… 新人如何快速融入技术实力强的前端团队：juejin.im/post/5cb860… 学习提升印记中文（各种中文开发文档）：www.docschina.org/ 前端学习方法：github.com/helloqingfe… 如何在工作内外获得持续的技术成长：juejin.im/post/5cbd74… 优秀的前端博客汇总：github.com/foru17/fron… 另外推荐我一直在关注的几位大佬的个人博客： 冴羽的博客：github.com/mqyqingfeng… 张鑫旭的博客：www.zhangxinxu.com/wordpress/ 左耳朵耗子：coolshell.cn/ 技术之外互联网术语大全：www.jianshu.com/p/9a7ca206c… 互联网沟通、问答、学习的艺术：zhuanlan.zhihu.com/p/41431775 经常加班至深夜，怎样才能保持身体健康：www.zhihu.com/question/21… 其实在这个信息发达的时代最不缺的就是资源，如何从众多的资源中获取到真正精华的部分，是非常重要的，资源在于精不在于多，强烈建议在保证深度的情况下再保证广度。小结希望你阅读本篇文章后可以达到以下几点： 从知识清单中找到自己的知识盲点与欠缺 具有知识体系化的思想，开始建立自己的知识体系 阅读文章时将知识归类到知识体系中，并不断完善自己的知识体系 从文章中获取到了有用的资源 文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[排序算法小结]]></title>
    <url>%2F2019%2F05%2F05%2Falgorithm-004-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[摘要:排序算法是算法中比较重要的基础算法，下面对常见的排序算进行简单的小结。目前只是一些基本实现，发现更好的实现方式再进行更新吧 各种排序算法的比较 类别 平均时间复杂度 最好 最坏 空间复杂度 稳定性 冒泡排序 O(n2) O(n) O(n2) O(1) 稳定 快速排序 O(nlog2n) O(nlog2n) O(n2) O(lob2n)~O(n) 不稳定 插入排序 O(n2) O(n) O(n2) O(1) 稳定 希尔排序 O(n1.3) O(n) O(n2) O(1) 不稳定 选择排序 O(n2 O(n) O(n2 O(1) 不稳定 堆排序 O(nlog2n) O(nlog2n) O(nlog2n) O(1) 不稳定 归并排序 O(nlog2n) O(nlog2n) O(nlog2n) O(n) 稳定 基数排序 O(d(r+n)) O(d(r+n)) O(d(r+n)) O(rd+n) 稳定 注： r 代表关键字基数，d 代表长度，n 代表关键字个数 冒泡排序动图演示： 实现代码： 1234567891011121314151617181920212223function bubbleSort(arr) &#123; if (arr.length &lt; 2) &#123; return arr; &#125; for (let i = arr.length - 1; i &gt; 0; i--) &#123; for (let j = 0; j &lt; i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; swap(arr, j, j + 1); &#125; &#125; &#125; return arr;&#125;function swap(arr, i, j) &#123; let temp = null; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;// testlet arr = [3, 5, 2, 7, 2, 77, 3, 74, 34, 23];bubbleSort(arr);console.log(arr); // [2, 2, 3, 3, 5, 7, 23, 34, 74, 77] 快速排序动图演示： 实现代码： 递归实现 12345678910111213141516171819202122function quickSort(arr)&#123; let len = arr.length if(len&lt;2)&#123; return arr &#125;else&#123; let flag = arr[0] let left = [] let right = [] for(let i=1, temp; i &lt; len: i++)&#123; temp = arr[i] if(temp&lt;flag)&#123; left.push(temp) &#125;else&#123; right.push(temp) &#125; &#125; return quickSort(left).concat(flag, quickSort(right)) &#125;&#125;let arr = [3, 5, 2, 7, 2, 77, 3, 74, 34, 23];console.log(quickSort(arr)); // [2, 2, 3, 3, 5, 7, 23, 34, 74, 77] 1234567891011121314151617181920212223242526272829303132333435363738function quickSort(arr, left, right) &#123; if (left &lt; right) &#123; let center = partSort(arr, left, right); quickSort(arr, left, center - 1); quickSort(arr, center + 1, right); &#125;&#125;function partSort(arr, left, right) &#123; if (left &lt; right) &#123; let key = arr[right]; let cur = left; let prev = cur - 1; // for (let cur = left; cur &lt; right; cur++) &#123; // if (arr[cur] &lt; key &amp;&amp; ++prev !== cur) &#123; // swap(arr, cur, prev); // &#125; // &#125; while (cur &lt; right) &#123; if (arr[cur] &lt; key &amp;&amp; ++prev !== cur) &#123; swap(arr, cur, prev); &#125; ++cur; &#125; // 将参考值放到正确的位置 swap(arr, ++prev, right); return prev; &#125;&#125;function swap(arr, i, j) &#123; let temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;//testlet arr = [3, 5, 2, 7, 2, 77, 3, 74, 34, 23];quickSort(arr, 0, 9);console.log(arr); // [2, 2, 3, 3, 5, 7, 23, 34, 74, 77] 非递归实现 123456789101112131415161718function quickSort(arr, left, right) &#123; let stack = []; stack.push(left); stack.push(right); while (stack.length) &#123; right = stack.pop(); left = stack.pop(); let flag = partSort(arr, left, right); if (flag - 1 &gt; left) &#123; stack.push(left); stack.push(flag - 1); &#125; if (flag + 1 &lt; right) &#123; stack.push(flag + 1); stack.push(right); &#125; &#125;&#125; 插入排序动图演示： 代码实现： 123456789101112131415161718192021function insertSort(arr) &#123; let len = arr.length; if (len &lt; 2) &#123; return arr; &#125; let cur = null; for (let i = 0; i &lt; len - 1; i++) &#123; cur = arr[i + 1]; let j = i; while (j &gt;= 0 &amp;&amp; cur &lt; arr[j]) &#123; arr[j + 1] = arr[j]; j--; &#125; arr[j + 1] = cur; &#125; return arr;&#125;//testlet arr = [3, 5, 2, 7, 2, 77, 3, 74, 34, 23];insertSort(arr);console.log(arr); // [2, 2, 3, 3, 5, 7, 23, 34, 74, 77] 选择排序动图演示： 代码实现： 12345678910111213141516171819202122232425function selectionSort(arr) &#123; let len = arr.length; if (len &lt; 2) &#123; return arr; &#125; for (let i = 0; i &lt; len; i++) &#123; let min = 0; for (let j = i; j &lt; len; j++) &#123; if (arr[j] &lt; arr[min]) &#123; min = j; &#125; &#125; swap(arr, i, min); &#125; return arr;&#125;function swap(arr, i, j) &#123; let temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;// testlet arr = [3, 5, 2, 7, 2, 77, 3, 74, 34, 23];selectionSort(arr);console.log(arr); // [2, 2, 3, 3, 5, 7, 23, 34, 74, 77] 堆排序动图演示： 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Heap &#123; constructor(data) &#123; this.data = data; &#125; // 一个点调整为最大堆 static maxHeapify(arr, i, size) &#123; let l = 2 * i + 1; let r = 2 * i + 2; let max = i; if (l &lt;= size &amp;&amp; arr[max] &lt; arr[l]) &#123; max = l; &#125; if (r &lt;= size &amp;&amp; arr[max] &lt; arr[r]) &#123; max = r; &#125; if (max !== i) &#123; Heap.swap(arr, max, i); Heap.maxHeapify(arr, max, size); &#125; &#125; sort() &#123; let arr = this.data; let len = arr.length; if (len &lt; 2) &#123; return arr; &#125; else &#123; // 建立最大堆(从最后一个父节点开始) for (let i = Math.floor(len / 2); i &gt;= 0; i--) &#123; Heap.maxHeapify(arr, i, len); &#125; // 排序，依次弹出最大值 for (let j = 0; j &lt; len; j++) &#123; Heap.swap(arr, 0, len - 1 - j); Heap.maxHeapify(arr, 0, len - 1 - j - 1); &#125; return arr; &#125; &#125; static swap(arr, i, j) &#123; let temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125;// testlet arr = [3, 5, 2, 7, 2, 77, 3, 74, 34, 23];let newArr = new Heap(arr);let res = newArr.sort();console.log(res); // [2, 2, 3, 3, 5, 7, 23, 34, 74, 77] 归并排序基数排序]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call/apply/bind的实现]]></title>
    <url>%2F2019%2F04%2F27%2F014-call-apply-bind%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[三个方法的作用： 改变this的指向 传参 call/apply 返回函数结果，bind 返回新的函数 call 的实现 ES3 的写法 123456789101112FUnction.prototype.mycall = function(obj)&#123; var obj = obj || window obj.fn = this var args = [] // 使用eval，会将传入的字符串当做JS解析，所以下面push的是字符串 for(var i=1, len = arguments.length; i&lt;len; i++)&#123; args.push('arguments['+ i +']) &#125; var res = eval('obj.fn('+ args +')') delete obj.fn return res&#125; 使用 ES6 12345678Function.prototype.mycall = function(obj) &#123; let obj = obj || window; obj.fn = this; let args = [...arguments].slice(1); let res = obj.fn(...args); delete obj.fn; return res;&#125;; apply 实现 ES3 的写法 1234567891011121314151617Function.prototype.myApply(obj,arr)&#123; var obj = obj || window obj.fn = this var res var args = [] if(!arr)&#123; res = obj.fn() &#125;else&#123; // 使用eval，会将传入的字符串当做JS解析，所以下面push的是字符串 for(var i=1, len = arr.length; i&lt;len; i++)&#123; args.push('arr['+ i +']') &#125; res = eval('obj.fn('+ args+')') &#125; delete obj.fn return res&#125; 使用 ES6 123456789101112Function.prototype.myApply(obj, arr)&#123; let obj = obj || window obj.fn = this let res if(!arr)&#123; res = obj.fn() &#125;else&#123; res = obj.fn(...arr) &#125; delete obj.fn return res&#125; bind 的实现 ES3 的写法 1234567891011121314151617181920Function.prototype.myBind = function(obj) &#123; if (typeof this !== "function") &#123; throw new TypeError("this is not a function") &#125; var self = this var arg = [].slice.call(arguments, 1) var fBind = function() &#123; var bindArgs = [].slice.call(arguments) return self.apply( this instanceof fNOP ? this : obj || window, args.concat(bindArgs) ) &#125; //创建中转函数，让fBind间接继承目标的原型 var fNOP = function() &#123; fNOP.prototype = this.prototype fBInd.prototype = new fNOP() &#125; return fBind&#125;]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[手写JS中深/浅拷贝]]></title>
    <url>%2F2019%2F04%2F27%2F013-%E6%89%8B%E5%86%99JS%E4%B8%AD%E6%B7%B1-%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[浅拷贝123456789function shallCopy(cource, target = &#123;&#125;) &#123; for (let key in source) &#123; // 排除原型上的属性 if (source.hasOwnProperty(key)) &#123; target[ket] = source[key]; &#125; &#125; return target;&#125; 深拷贝1234567891011function deepCopy(source) &#123; let target = Array.isArray(source) ? [] : &#123;&#125;; for (let key in source) &#123; if (typeof source[key] === "object") &#123; target[key] = deepCopy(source[key]); &#125; else &#123; target[key] = source[key]; &#125; &#125; return target;&#125; 另外 JSON.parse(JSON.stringify(obj))也可以实现深拷贝但是：undefined，function，Symbol 不支持]]></content>
      <tags>
        <tag>深浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中继承的写法]]></title>
    <url>%2F2019%2F04%2F27%2F012-JS%E4%B8%AD%E7%BB%A7%E6%89%BF%E7%9A%84%E5%86%99%E6%B3%95%2F</url>
    <content type="text"><![CDATA[原型链继承123456789101112131415function Sup&#123; this.supName = 'sup' this.arr = [1, 2, 3]&#125;Sup.prototype.getSupName = function()&#123; console.log(this.supName)&#125;function Sub()&#123; this.subName = 'sub'&#125;Sub.prototype.getSubName = function()&#123; console.log(this.subName)&#125;Sub.prototype = new Sup() 缺点：父类的引用属性会被子类的实例共享，子类实例不能向父类传参 构造函数继承1234567891011function Sup(name) &#123; this.name = name; this.arr = [1, 2, 3];&#125;Sup.prototype.getName = function() &#123; console.log(this.name);&#125;;function Sub(name, age) &#123; Sup.call(this, name); this.age = age;&#125; 优点：父类引用属性不会被共享；子类构建实例可以传参缺点：父类的方法不能复用（不能继承父类原型的方法） 组合式继承123456789101112function Sup(name) &#123; this.name = name; this.arr = [1, 2, 3];&#125;Sup.prototype.getName = function() &#123; console.log(this.name);&#125;;function Sub(name, age) &#123; Sub.call(this, name); // 一次调用父类构造函数 this.age = age;&#125;Sub.prototype = new Sup(); // 二次调用父类构造函数 优点：父类引用属性不会被共享；子类实例化可以传参；父类方法可以复用缺点：两次调用父类构造函数 原型式继承12345function create(obj) &#123; function F() &#123;&#125; F.prototype = obj; return new F();&#125; 缺点：父类应用属性被共享实际就是对传入的对象执行了一次浅拷贝 寄生式继承1234567function createAnother(obj)&#123; let another = create(obj) another.sag = function()&#123; console.log('hello) &#125; return another&#125; 缺点：不能做到函数复用 寄生组合继承123456789101112131415161718192021function Sup(name) &#123; this.name = name; this.arr = [1, 2, 3];&#125;Sup.prototype.getName = function() &#123; console.log(this.name);&#125;;function Sub(name, age) &#123; Sup.call(this, name); this.age = age;&#125;Sub.prototype.getAge = function() &#123; console.log(this.age);&#125;;// 这里的目的是要继承父类的方法，对父类原型进行浅拷贝function inherit(sub, sup) &#123; let peototype = create(sup.prototype); prototype.constructor = Sub; Sub.prototype = prototype;&#125;inherit(Sub, Sup); 最后继承父类方法还可用以下方式实现： 使用Object.create() 12Sub.prototype = Object.create(Sup.prototype);Sub.prototype.constructor = Sub; ES6 中的Object.setPrototypeOf()可以直接关联，不用手动设置constructor 1Object.setPrototypeOf(Sub.prototype, Sup.prototype); ES6 继承的实现1234567891011121314151617181920class Sup &#123; constuctor(x, y) &#123; console.log(x + y); &#125; toString() &#123; return "sup"; &#125;&#125;class Sub extends Sup &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125; toString() &#123; // 调用父类的toString()方法 return this.color + " " + super.toString(); &#125;&#125;]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端性能优化小结]]></title>
    <url>%2F2019%2F04%2F24%2F011-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前端性能优化，大方向来讲，可从两方面入手，网络层面与页面渲染层面 网络层面从输入 url 到显示页面，在网络层面主要包含三个过程：1 DNS 解析2 TCP 连接3 HTTP 请求与响应 请求过程优化（http 请求优化）http 请求优化主要有两个方向：1 减少请求次数2 减少单次请求消耗的时间 构建工具性能调优 减少 loader 所做的事情1 用 include、exclude 来避免不必要的转译2 将转移结果缓存文件系统 借助其他工具将第三方依赖单独打包 文件结构可视化，寻找体积过大的原因 删除冗余代码 按需加载 图片性能优化 JPEG/JPE特点： 有损压缩，体积小，加载快，不支持透明使用场景：呈现色彩丰富的图片，如大的背景图，轮播图 png-8/png-24特点：支持透明，体积大使用场景：线条颜色对比强烈的颜色和背景，如 logo SVG特点：文本文件，体积小不失真，兼容性好，但渲染成本较高 base64特点：文本文件，依赖编码，小图标解决方案base64 是一种编码方式，不是图片格式使用 base64 也是为了减少请求次数，是作为 CSS sprite 的补充而存在，是一种用于传输 8bit 字节码的编码方式，通过对图片进行 base64 编码，可以直接将编码结果写入 HTML 或者 CSS，从而减少 http 请求。 webP特点：全能，兼容差google 开发的旨在加快图片加载速度，支持有损压缩与无损压缩 减少网络请求减少网络请求 =&gt; 存储 =&gt; 1 浏览器缓存机制 2 本地存储 浏览器缓存机制缓存能够减少 IO 消耗，提高访问速度，浏览器缓存是一种操作简单、效果显著的前端性能优化手段。浏览器缓存机制包含四个方面(按照资源获取请求优先级)：1 Memory Cache2 Service Worker Cache3 HTTP Cache4 Push Cache Memory Cache 内存中的缓存浏览器最先尝试命中，响应速度最快它与渲染进程存在生死相依的关系，当进程结束后，内存中的数据也就不存在了 Service Worker Cache Service Worker 是一种独立于主线程之外的 JavaScript 线程，它脱离浏览器窗体，因此无法直接访问 DOM。也就使得它的行为无法干扰到页面的性能，因此，借助它我们可以实现离线缓存，消息推送，网络代理等功能。借助 Service Worker 实现的离线缓存就称为Service Work Cache Service Worker 的生命周期包括install, active, working三个阶段。一旦 install ，除非主动终止，就将始终存在，只会在 active 和 working 之间切换。 Service Worker 对协议有要求，以 HTTPS 为前提。 注意：Service Worker 处理网络请求的后台服务，通信使用 postMessageWeb Worker 模仿多线程，通信使用 postMessagewebsocket 在客户端与服务端之间创建一个开放的连接，允许在一个连接导航进行双向通信 HTTP Cachehttp 缓存分为强缓存与协商缓存,强缓存的优先级高于协商缓存，在强缓存命中失败时，才会走协商缓存。 强缓存强缓存是利用 http 头部的 Expries 和 Cache-Control 来控制，当强缓存命中后，不会再与服务器发生通信。服务器返回响应时，在 Response Headers 中将过期时间写入 expires 字段；exprise 是一个时间戳 =&gt; 依赖本地时间 =&gt; 服务器和客户端时间可能不同，也可手动更改 =&gt; 无法达到预期 =&gt; http1.1 增加了 Cache-ControlCache-Control 相对于 expires 更加准确，它的优先级也更高。当 Cache-Control 与 expires 同时出现时，我们以 Cache-Control 为准。 1cache-control: max-age=3600, s-maxage=31536000 s-maxage 优先级高于 max-age，两者同时出现时，优先考虑 s-maxage。如果 s-maxage 未过期，则向代理服务器请求其缓存内容。s-maxage 仅在代理服务器中生效，客户端中我们只考虑 max-age。public 与 privatepublic 与 private 是针对资源是否能够被代理服务缓存而存在的一组对立概念。public：即可被浏览器缓存，又可以被代理服务器缓存。private：默认值，只能被浏览器缓存。no-store 与 no-cacheno-cahe: 不会向浏览器询问，直接向服务器询问 =&gt; 进入协商缓存。no-store：不使用任何缓存，直接向服务器发起请求，并下载完整的响应。 协商缓存协商缓存依赖浏览器与服务器之间的通信协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，如果服务端提示资源未改动，资源会被重定向到浏览器缓存，对应状态码是 304 Not ModifiedLast-Modified 是一个时间戳，首次请求时随着响应头返回下次请求时，会带上 If-Modefied-Since，它的值就是上次返回的 Last-Modified它的缺点：1 我们编辑了文件，但文件的内容没有改变。会被当做新资源，进而引发一次完整的响应——不该重新请求的时候，也会重新请求。2 当我们修改文件的速度过快时（比如花了 100ms 完成了改动），由于 If-Modified-Since 只能检查到以秒为最小计量单位的时间差，所以它是感知不到这个改动的——该重新请求的时候，反而没有重新请求了。=&gt; 于是出现 EtagEtag 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的。首次请求时，响应头部会带有Etag字段下次请求时就会带上一个If-None-Match字段，值为上次 Etag，以供服务器比较Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。 Push CachePush Cache 是指 HTTP2 在 server push 阶段存在的缓存一些特性：Push Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。 本地存储Cookiehttp 是无状态的，Cookie 的本职工作就是用来维持状态的。Cookie 性能缺陷：Cookie 的体积上限为 4KB，超过将被裁剪，只能用来存储少量信息Cookie 是紧跟域名的，默认为 Cookie 页面的主机名，也可手动设置同一个域名下的所有请求都会携带 Cookie，哪怕是一张图片一个 css 文件，容易影响性能。 Web StorageWeb Storage 是 HTML5 专门为浏览器存储而提供的数据存储机制。它又分为 Local Storage 与 Session Storage。 Web Storage 的特点：存储容量大：根据浏览器的不同可达 5-10M仅位于浏览器端，不予服务器发生通信。 Local Storage 与 Session Storage 的区别生命周期：Local Storage 是持久的本地存储，Session Storage 是临时的本地存储，会话级别，页面关闭时，它也就随之释放作用域：两者都遵循同源策略；但 Session Storage 特别的一点在于，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 Session Storage 内容便无法共享。 应用场景Local Storage 在存储方面没有什么特别的限制，理论上 Cookie 无法胜任的、可以用简单的键值对来存取的数据存储任务，都可以交给 Local Storage 来做。Session Storage 更适合用来存储生命周期和它同步的会话级别的信息。 indexDBIndexedDB 是一个运行在浏览器上的非关系型数据库。IndexedDB 可以看做是 LocalStorage 的一个升级，当数据的复杂度和规模上升到了 LocalStorage 无法解决的程度，可以请出 IndexedDB 来帮忙。 页面渲染层服务端渲染服务端渲染 SSR，是一个箱规的概念，对立面是客户端渲染 客户端渲染服务器把要渲染的静态文件发送给客户端，客户端将加载过来的资源，在浏览器里运行一遍 JS，根据 JS 运行结果生成对应的 DOM页面呈现的内容在 html 源文件里是找不到的 服务端渲染，由服务器将需要的组件或者页面渲染成 HTML 字符串，然后把它返回给客户端，客户端加载资源后可直接渲染然后呈现给用户页面呈现的内容在 html 源文件里可以找到 优缺点：首屏体验提升，有利于 SEO本质是把浏览器该做的事分给服务器去做，容易造成服务器压力 浏览器渲染机制浏览器的内核 常见浏览器内核有：Trident（IE）、Gecko(火狐)、Blink(Chrome,Opera)、Webkit(Safari)Blink 是基于 webkit 衍生而来的一个分支各个浏览器下代码渲染具有差异性，其原因就是因为内核的不同，浏览器内核决定了浏览器解释网页语法的方式。浏览器内核可分两个部分：渲染引擎（Layout Engine/Rendering Engine）、JS 引擎。渲染引擎包括了：HTML 解释器、CSS 解释器、布局、网络、存储、图形、音视频、图片解码器等等。HTML 解释器：将 HTML 文档经过词法分析输出 DOM 树。CSS 解释器：将 CSS 文档解析成样式规则。图层布局计算模块：布局计算每个对象的精确位置和大小。视图绘制模块：进行具体节点的图像绘制，将像素渲染到屏幕上。JavaScript 引擎：编译执行 JavaScript 代码。 浏览器渲染过程 1 解析 HTML：这一步浏览器执行了所有加载逻辑，在解析 HTML 的过程中发出了页面渲染需求的各种外部资源请求。2 计算样式： 识别并加载所有的 CSS 样式信息与 DOM 树合并，最终生成页面 render 树(:after :before 这样的伪元素在这个环节被构建到 DOM 中)。3 绘制图层：把每一个页面图层转换为像素，并对所有的媒体文件进行解码。4 整合图层，得到页面：合并各个图层，并将数据由 CPU 输出给 GPU，最终绘制在屏幕上。渲染过程中的一些树 DOM 树：解析 HTML 创建的是 DOM 树(DOM Tree):渲染引擎开始解析 HTML 文档，转换书中的标签得到 DOM 节点，它被称为‘内容树’。 CSSOM 树：解析 CSS 得到就是 CSSOM 树，CSSOM 解析过程与 DOM 解析过程是并行的。 渲染树：CSSOM 与 DOM 结合，之后得到的就是渲染树(Render Tree)。线面两个是动词 布局渲染树：从根节点递归调用，计算每个元素的精确大小、位置，得到基于渲染树的布局渲染树(Layout of hte render tree)。 绘制渲染树：遍历渲染树，使用 UI 后端层来绘制每个节点 CSS 优化CSS 查找样式规则时，是从右往左的性能优化总结：1 避免使用通配符，只对需要永奥的元素进行选择。2 关注可以通过继承实现的属性，避免重复匹配重复定义。3 少食用标签选择器，如果可以，使用类选择器替代。4 id 和 class 选择器不添加多余的标签选择器5 减少嵌套，后代选择器开销最高，应该尽量将选择器的深度降低。 CSS 与 JS 加载优化HTML、CSS、JS 都具有阻塞渲染的特性CSS 的阻塞浏览器在构建 CSSOM 的过程中，不会渲染任何已经处理的内容，即使 DOM 解析完成，只要 CSSOM 还没完成，渲染这个事情就不 OK。浏览器在构建 CSSOM 的过程中，不会渲染任何已处理的内容。=&gt; CSS 是阻塞渲染的资源，需要尽早的下载。=&gt; 放在 head 里，启用 CDN 等。JS 的阻塞JS 引擎是独立于渲染引擎的，当 HTML 解析器遇到一个 script 标签是，它会停止渲染，将控制权交给 JS 引擎，JS 执行完毕后，控制权归还给渲染引擎，继续 DOM 和 CSSOM 的构建。 JS 加载的方式1 正常加载 1&lt;script src="index.js"&gt;&lt;/script&gt; 该方式会阻塞浏览器，必须等 JS 加载执行完毕才能做其他的。2 async 1&lt;script src="index.js" async&gt;&lt;/script&gt; 使用 async 属性，加载是异步的，加载过程中不会阻塞浏览器，加载结束会立即执行。执行顺序不一定。3 defer 1&lt;script src="index.js" defer&gt;&lt;/script&gt; 使用 defer 属性，加载是异步的，加载结束后，不会立即执行，整个文档解析完成，DOMContentLoaded 事件即将被触发时，被 defer 标记的 JS 文件才会开始执行。这里是顺序执行。 defer 和 async 使用场景:**当脚本与 DOM 元素和其他脚本之间依赖关系不强是，选用 async。当脚本依赖于 DOM 元素和其他脚本的执行结果时，选用 defer。 DOM 优化首屏渲染优化]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[边距重叠问题]]></title>
    <url>%2F2019%2F04%2F22%2F%E5%9D%91-002-%E8%BE%B9%E8%B7%9D%E9%87%8D%E5%8F%A0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[边距重叠问题比邻的两个或多个普通流中的块元素在垂直方向上的外边距会合并为一个外边距水平方向是不会发生重叠的情况 边距计算方法：全部为正值的情况，取值最大的有正有负的情况，分别取绝对值最大的求和都是负值的情况，取绝对值最大的，从零开始负向位移 解决方法 =&gt; 触发BFCBFC：块级格式化上下文原理：1、 属于同一BFC的垂直方向会发生重叠，属于不同BFC的不会重叠2、 BFC的区域不会与浮动元素的box发生重叠3、 BFC是页面上一个独立的容器，里面跟外面不会互相影响4、 计算BFC高度时，浮动元素也参与计算触发条件1、 根元素2、 float不为none3、 position为fixed和absolute4、 overflow为hidden和auto5、 display为inline-block、table-cell、flex、inline-flex 补充：BFC使用场景1、 自适应两栏布局 12.aside&#123;float:left;&#125;.main&#123;overflow:hidden;&#125; 2、清除浮动 12.parent&#123;overflow:hidden;&#125;.child&#123;float:left;&#125; 3、防止垂直边距重叠 12345678910&lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;style&gt;div&#123; overflow:hidden;&#125;&lt;/style&gt;]]></content>
      <categories>
        <category>坑</category>
      </categories>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS百分比参照]]></title>
    <url>%2F2019%2F04%2F22%2F%E5%9D%91-001-CSS%E7%99%BE%E5%88%86%E6%AF%94%2F</url>
    <content type="text"><![CDATA[CSS 百分比的坑top, height 百分比参照包含块的高度left, margin, padding, width 百分比参照包含块的宽度translate(-50%, -50%) 百分比参照于自身的宽高background-position 百分参照于（图片区域-图片的位图像素值）]]></content>
      <categories>
        <category>坑</category>
      </categories>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-605 种花问题]]></title>
    <url>%2F2019%2F04%2F22%2Falgorithm-003-%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目描述假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。 给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。 示例 1: 输入: flowerbed = [1,0,0,0,1], n = 1输出: True示例 2: 输入: flowerbed = [1,0,0,0,1], n = 2输出: False注意: 数组内已种好的花不会违反种植规则。输入的数组长度范围为 [1, 20000]。n 是非负整数，且不会超过输入数组的大小。 问题分析=&gt; 如果题目没有给出1、0的描述，应该首先将问题抽象成出来；=&gt;怎么才能种花？两种情况 =&gt; 边界情况： =&gt; 左边界：00…,01…只有在第第一个位置为0，且第二个位置为零的时候，左边第一个位置才能种花 =&gt; 右边界：…00,…10 右边能不能种花，取决于倒数第二个位置，如果为零，则最右边可以种花 =&gt;中间情况： 000… 只有某元素左右两边都是0的时候，中间该元素才能种花 代码1234567891011121314151617181920212223242526272829let flowers = (field, n) =&gt; &#123; //记录最多能种多少 let count = 0 // 为了最右边位置能够比较左右元素值，这里添加一个默认元素0 field.push(0) for(let i=0, len=field.length-1; i&lt;len; i++)&#123; // 如果i位置上的元素是0，才进行判断，否则直接跳到下个元素 if(field[i] === 0)&#123; if(i === 0 &amp;&amp; field[1] === 0)&#123; count++ // 这里应该多跳过一个元素 i++ &#125;else if(field[i-1] === 0 &amp;&amp; field[i+1] === 0)&#123; count ++ i++ &#125; &#125; &#125; return count &gt;= n&#125;// testlet field1 = [1,0,0,0,1]let field2 = [0,0,1,0,0,0,1,0]let field3 = [0,0,1,0,0,0,1,0,0]console.log('field1-1',flowers(field1, 1)) // trueconsole.log('field1-2',flowers(field1, 2)) // falseconsole.log('field2-2',flowers(field2, 2)) // trueconsole.log('field3-3',flowers(field3, 3)) // true]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-914 卡牌分组]]></title>
    <url>%2F2019%2F04%2F22%2Falgorithm-002-%E5%8D%A1%E7%89%8C%E5%88%86%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目描述给定一副牌，每张牌上都写着一个整数。 此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组： 每组都有 X 张牌。组内所有的牌上都写着相同的整数。仅当你可选的 X &gt;= 2 时返回 true。 示例 1： 输入：[1,2,3,4,4,3,2,1]输出：true解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]示例 2： 输入：[1,1,1,2,2,2,3,3]输出：false解释：没有满足要求的分组。示例 3： 输入：[1]输出：false解释：没有满足要求的分组。示例 4： 输入：[1,1]输出：true解释：可行的分组是 [1,1]示例 5： 输入：[1,1,2,2,2,2]输出：true解释：可行的分组是 [1,1]，[2,2]，[2,2] 提示： 1 &lt;= deck.length &lt;= 100000 &lt;= deck[i] &lt; 10000 问题分析：题目要求每组都有 x 张牌，=&gt; 那么只有当牌上整数对应的数量是 x 的倍数的时候，才能成功分组，=&gt; 也就是要求最大公约数，=&gt; 先对整副牌进行排序，统计不同整数的数量=&gt; 关键点在于求两个数的最大公约数，然后再与其他数求公约数假設兩個數a,b当 a = cb 时，b就是最大公约数当 a = cb + d时，继续寻找 b 和 d 的关系 当 b = d 时，d就是最大公约数 当 b = e*d + f时，继续寻找 d 和 f 的关系重复上述过程，直到能够被整除，这也就是一个递归的过程 代码1234567891011121314151617181920212223242526272829303132let grouping = arr =&gt; &#123; //求兩個數的最大公约数 let greatestComDivisor = (a, b) =&gt; &#123; if (b === 0) &#123; return a; &#125; else &#123; return greatestComDivisor(b, a%b) &#125; &#125;; // 用正则将不同整数分组存放， let cards = arr.sort((x,y)=&gt;x-y).join('').match(/(\d)\1+|\d/g) while(cards.length &gt; 1)&#123; let a = cards.shift().length let b = cards.shift().length let num = greatestComDivisor(a, b) if(num === 1)&#123; return false &#125;else( //插入公约数个#号，进入下一轮比较 cards.unshift('#'.repeat(num)) ) &#125; // 如果cards为空，则没有最大公约数，否则看第一个元素长度，如果大于1，则为true return cards.length ? cards[0].length &gt; 1 : false&#125;;//testlet ret = grouping([1,1,2,2,2,2])console.log(ret) // truelet ret2 = grouping([1,1,1,2,2,2,3,3])console.log(ret2) // false]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-17 电话号码的字母组合]]></title>
    <url>%2F2019%2F04%2F21%2Falgorithm-001-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[题目描述给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 12输入："23"输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]. 说明:尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 问题分析需要根据输入的数字映射到对应的字母，根据输入的数字对进行组合：思路一：循环嵌套思路二：两两组合，然后递归 代码123456789101112131415161718192021222324252627282930313233343536 let phonenum = (str) =&gt; &#123; // 1 建立电话号码键盘映射 let map = ['', '', 'abc', 'def', 'ghi', 'jkl', 'mon', 'pqrs','tuv', 'wxyz'] // 234 =&gt; [2,3,4] let num = str.split('') // 2 保存映射后的内容 23 =&gt; ['abc', 'def'] let code = [] num.forEach(item=&gt;&#123; if(map[item])&#123; code.push(map[item]) &#125; &#125;) // 3. 进行组合 let comb = (arr) =&gt; &#123; // 临时变量用来保存前两项组合的结果 let temp = [] for(let i=0, il = arr[0].length; i&lt;il; i++)&#123; for(let j=0,jl=arr[1].length; j&lt;jl; j++)&#123; temp.push(`$&#123;arr[0][i]&#125;$&#123;arr[1][j]&#125;`) &#125; &#125; arr.splice(0, 2, temp) if(arr.length&gt;1)&#123; comb(arr) &#125;else&#123; return temp &#125; return arr[0] &#125; // 4.调用并返回结果 return comb(code)&#125;//testphonenum('345')// ["dgj", "dgk", "dgl", "dhj", "dhk", "dhl", "dij", "dik", "dil", "egj", "egk", "egl", "ehj", "ehk", "ehl", "eij", "eik", "eil", "fgj", "fgk", "fgl", "fhj", "fhk", "fhl", "fij", "fik", "fil"]]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3之flex基本用法小结]]></title>
    <url>%2F2019%2F04%2F20%2F010-CSS3%E4%B9%8Bflex%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[伸缩容器 display 语法 123display: flex | inline-flexflex: 块伸缩容器inline-flex:内联伸缩容器 注意：float,clear,vertical-align在伸缩项目上没有效果 伸缩流方向 flex-direction主要用来定义主轴，从而定义了伸缩项目在容器中的伸缩方向 语法 1flex-direction: row | row-reverse | column | column-reverse 参数功能 row：ltr排版下从左向右排列，rtl排版下从右向左 row-reverse：与row排列相反 column：类似row，方向是从上到下 column-reverse：类似于row-reverse，方向是从下到上 伸缩换行flex-wrap主要用来定义伸缩容器里是单行显示还是多行显示，侧轴的方向决定了新行堆放的方向 语法 1flex-wrap: nowrap | wrap | wrap-reverse 参数功能 nowrap：伸缩容器单行显示，ltr从左到右，rtl从右到左 wrap：伸缩容器多行显示，ltr从左到右，rtl从右到左 wrap-reverse：伸缩容器多行显示，ltr从右到左，rtl从左到右（与wrap相反） 伸缩流方向与换行flex-flow这是flex-direction和flex-wrap属性的简写版,同时定义主轴和侧轴 1flex-flow: &lt;'flex-direction'&gt; | &lt;'flex-wrap'&gt; 参数功能 flex-direction：主轴 flex-wrap：侧轴 注意：flex-flow与writing-mode有直接联系,当使用writing-mode: vertical-rl时转向垂直布局，flex-flow:row将垂直排列伸缩项目，column将水平排列项目 主轴对齐justify-content主要用来设置伸缩项目沿主轴线的对齐方式 语法 1justify-content: flex-start | flex-end | center | space-between | space-around 参数功能 flex-start：伸缩项目向一行的起始位置靠齐。 flex-end：伸缩项目向一行的结束位置靠齐。 center：伸缩项目向一行中间位置靠齐。 space-between：伸缩项目会平均地分布在行里，第一个项目在开始位置，最后一个项目在终点位置。 space-around：伸缩项目会平均分布在行里，两端保留一半的空间。 侧轴对齐align-items和align-self align-items控制伸缩项目在侧轴的对齐方式，align-self控制伸缩项目自身在侧轴的对齐方式。 align-items 语法 1align-items: flex-start | flex-end | center | baseline | stretch 参数功能： flex-start：伸缩项目靠侧轴起始边。 flex-end：伸缩项目在侧轴终点边的外边距靠住该行在侧轴终点边。 center：伸缩项目的外边距盒在该行的侧轴上居中放置。 baseline：伸缩项目根据伸缩项目的基线对齐。 stretch：默认值，伸缩项目拉伸填充整个伸缩容器。 align-self align-self属性主要用来设置单独伸缩项目在侧轴的对齐方式。可以覆盖该伸缩项目的伸缩容器的align-items属性。 语法 1align-self: flex-start | flex-end | center | baseline | stretch 如果伸缩项目的任一个侧轴上的外边距为auto，则align-self没有效果。 伸缩行align-contentalign-content属性会更改flex-wrap的行为，它和align-items相似。主要来调准伸缩行在伸缩容器中的对齐方式，与调准伸缩项目在主轴上对齐方式的justify-content类似。 语法 1align-content: flex-start | flex-end | center | space-between | space-around | stretch 参数功能 flex-start：各行向伸缩容器起点位置堆叠。 flex-end:各行向伸缩容器结束位置堆叠。 center：各行向伸缩容器的中间位置堆叠。 space-between：各行在伸缩容器中平均分布。 space-around：各行在在伸缩容器中平均分布，两边处各有一般的空间。 stretch：默认值，各行将会伸展以占用额外的空间。 伸缩性flex 语法 1flex: none | [&lt;flex-grow&gt; &lt;flex-shrink&gt;? || &lt;flex-basis&gt;] 参数功能 flex-grow: 定义伸缩项目的拉伸因子，默认值0，不可继承。 flex-shrink: 指定了 flex 元素的收缩规则。flex 元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值。默认值为1，不可继承。 flex-basis: 指定了 flex 元素在主轴方向上的初始大小,默认值auto。 大多数情况下，需要将 flex 设置为 auto，initial，none，或一个无单位正数。 flex: 0 auto = flex: initial = felx: 0 1 auto flex: auto = flex: 1 1 auto flex: none = flex: 0 0 auto flex:正数 = flex: 正数 1 0]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文本溢出&内容溢出]]></title>
    <url>%2F2019%2F04%2F20%2F009-%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%26%E5%86%85%E5%AE%B9%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[溢出文本 text-overflow 语法 123text-overflow:clip | ellipsisclip:不显示省略标记...ellipsis:显示省略标记，插入在最后一个字符 三个条件 需要结合强制文本在一行white-space:nowrap 和溢出内容隐藏over-flow:hidden使用 并且需要定义内容宽度width 示例clip:12345678text-overflow-clip&#123; width:100px; padding:10px; border: 1px solid #ccc; text-overflow:clip; /*文本剪切*/ white-space:nowrap; /*强制不换行*/ overflow:hidden; /* 溢出隐藏*/&#125; ellipsis:12345678text-overflow-clip&#123; width:100px; padding:10px; border: 1px solid #ccc; text-overflow:ellipsis; white-space:nowrap; /*强制不换行*/ overflow:hidden; /* 溢出隐藏*/&#125; 内容溢出overflowoverflow是CSS2.1中的特性，CSS3增加了overflow-x和overflow-y 语法 12345/* 定义水平方向内容溢出剪切： */overflow-x:visible | hidden | scroll | auto | no-display | no-content/* 定义垂直方向内容溢出剪切： */overflow-y:visible | hidden | scroll | auto | no-display | no-content 参数功能： visible:默认值，元素将被剪切为包含对象的窗口大小，且clip属性设置失效 auto：在需要时剪切内容并添加滚动条 hidden：内容溢出时，溢出内容将隐藏，且不显示滚动条 scroll：不管内容有没有溢出，都显示滚动条。x, y对应横向和纵向 no-display：内容溢出时不显示元素，类似于添加了display:none no-content：当内容溢出时不显示内容，类似于添加visibility:hidden]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[canvas基础知识小结]]></title>
    <url>%2F2019%2F04%2F20%2F007-canvas%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[总结一些基础知识 画一条直线 moveTo设置起点，lineTo设置下一坐标 123456789101112131415161718192021&lt;canvas id="canvas"&gt;&lt;/canvas&gt;&lt;script&gt; window.onload = function () &#123; var canvas = document.getElementById("canvas"); canvas.width = 800; canvas.height = 800; var context = canvas.getContext("2d"); // 设置状态 context.beginPath(); context.moveTo(100, 100);// 起点 context.lineTo(700, 700);// 下一点坐标 context.closePath(); context.lineWidth = 10;// 线宽 context.strokeStyle = "#0f0";// 颜色 // 绘制 context.stroke(); &#125;&lt;/script&gt; lineCap属性 - 设置线段起始位置的样式，取值如下butt:(default)默认值round:圆头square:方头 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;canvas id="canvas"&gt;&lt;/canvas&gt;&lt;script&gt; window.onload = function () &#123; var canvas = document.getElementById("canvas"); canvas.width = 800; canvas.height = 800; var context = canvas.getContext("2d"); context.lineWidth = 30; context.strokeStyle = "tomato"; context.beginPath(); context.moveTo(100, 100); context.lineTo(400, 100); context.lineCap = "butt"; context.stroke(); context.beginPath(); context.moveTo(100, 200); context.lineTo(400, 200); context.lineCap = "round"; context.stroke(); context.beginPath(); context.moveTo(100, 300); context.lineTo(400, 300); context.lineCap = "square"; context.stroke(); // 辅助线 context.lineWidth = 1; context.beginPath(); context.moveTo(100, 50); context.lineTo(100, 350); context.stroke(); context.beginPath(); context.moveTo(400, 50); context.lineTo(400, 350); context.stroke(); &#125;&lt;/script&gt; 结果如下： lineJoin属性- 两条直线相交处的样式，可取值如下：miter：(default)，尖角，miterLimit 默认值10,控制尖角的长度，只有设置miter时生效。bevel：斜接round: 圆角1234567891011121314151617181920212223242526272829303132333435363738&lt;canvas id="canvas"&gt;&lt;/canvas&gt;&lt;script&gt; window.onload = function () &#123; var canvas = document.getElementById("canvas"); canvas.width = 800; canvas.height = 800; var context = canvas.getContext("2d"); context.lineWidth = 50; context.strokeStyle = "tomato"; context.beginPath(); context.moveTo(300, 300); context.lineTo(400, 100); context.lineTo(500, 300); context.lineJoin = "miter"; context.miterLimit = 10; context.stroke(); context.beginPath(); context.moveTo(300, 500); context.lineTo(400, 300); context.lineTo(500, 500); context.lineJoin = "bevel"; context.miterLimit = 10; context.stroke(); context.beginPath(); context.moveTo(300, 700); context.lineTo(400, 500); context.lineTo(500, 700); context.lineJoin = "round"; context.miterLimit = 10; context.stroke(); &#125;&lt;/script&gt; 示意图如下： 画一个矩形(1).直接使用连线的方式画出矩形。123456789101112131415161718192021222324&lt;canvas id="canvas"&gt;&lt;/canvas&gt;&lt;script&gt; window.onload = function () &#123; var canvas = document.getElementById("canvas"); canvas.width = 800; canvas.height = 800; var context = canvas.getContext("2d"); context.beginPath(); context.moveTo(100, 100); context.lineTo(600, 100); context.lineTo(600, 600); context.lineTo(100, 600); context.lineTo(100, 100);//可以省略，closePath()会自动封闭图形 context.closePath(); context.lineWidth = 10; context.strokeStyle = "#0f0"; context.stroke(); &#125;&lt;/script&gt; (2).使用context.rect(x, y, width, height)规划路径，这里只规划路径，不会绘制。context.fillRect(x, y, width, height), context.strokeRect(x, y, width, height)不但规划路径，还将矩形直接绘制出来。1234567891011121314151617181920212223242526272829303132333435363738&lt;canvas id="canvas"&gt;&lt;/canvas&gt;&lt;script&gt; window.onload = function () &#123; var canvas = document.getElementById("canvas"); canvas.width = 800; canvas.height = 800; var context = canvas.getContext("2d"); drawRect(context, 100, 100, 300, 200, 5, "blue", "red"); drawRect2(context, 250, 200, 300, 200, 5, "blue", "rgba(0, 255, 0, 0.5)"); &#125; function drawRect(cxt, x, y, width, height, borderWidth, borderColor, fillColor)&#123; cxt.beginPath(); cxt.rect(x,y, width, height); // 规划路径 cxt.closePath(); cxt.lineWidth = borderWidth; cxt.fillStyle = fillColor; cxt.strokeStyle = borderColor; cxt.fill(); cxt.stroke(); &#125; function drawRect2(cxt, x, y, width, height, borderWidth, borderColor, fillColor)&#123; cxt.lineWidth = borderWidth; cxt.fillStyle = fillColor; cxt.strokeStyle = borderColor; cxt.fillRect(x, y, width, height); // 填充 cxt.strokeRect(x, y, width, height); &#125;&lt;/script&gt; fillStyle, strokeStyle 可取颜色值如下：#ffffff 、#fff、rgb(255, 255, 100)、rgba(100, 100, 100, 0.8)、hsl(20, 62%, 28%)、 hsla(30, 82%, 45%, 0.6)、red 图形变换 位移：translate(x, y) 旋转：rotate(deg) 缩放：scale(sx, sy) , sx - x方向缩放倍数，sy - y方向缩放倍数。 变换矩阵a c e &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; a - 水平缩放(1) ;&#160;&#160; b - 水平倾斜(0)b d f &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; c - 垂直倾斜(0) ;&#160;&#160; d - 垂直缩放(1)0 0 1 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; e - 水平位移(0);&#160;&#160; f - 垂直位移(0) 设置变换矩阵：transform(a, b, c, d, e, f)setTransform(a, b, c, d, e, f) 设置变换后的默认值 canvas状态的保存与恢复context.save();context.restore();123456789101112131415161718192021222324&lt;canvas id="canvas" style="border: 1px solid #000;"&gt;&lt;/canvas&gt;&lt;script&gt; window.onload = function () &#123; var canvas = document.getElementById("canvas"); canvas.width = 800; canvas.height = 800; var context = canvas.getContext("2d"); context.save(); context.fillStyle = "red"; context.translate(100, 100); context.fillRect(0, 0, 400, 400); context.restore(); context.save(); context.fillStyle = "green"; context.translate(300, 300); context.fillRect(0, 0, 400, 400); context.restore(); &#125;;&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;canvas id="canvas"&gt;&lt;/canvas&gt;&lt;script&gt; window.onload = function () &#123; var canvas = document.getElementById("canvas"); canvas.width = 800; canvas.height = 800; var context = canvas.getContext("2d"); context.fillStyle = "#000"; context.fillRect(0, 0, canvas.width, canvas.height); for(var i = 0; i &lt; 200; i++)&#123; var r = Math.random()*10+10; var x = Math.random()*canvas.width; var y = Math.random()*canvas.height; var a = Math.random()*360; drawStar(context, x, y, r, a) &#125; &#125;; function drawStar(cxt, x, y, R, rot)&#123; var rot = rot || 0; cxt.fillStyle = "#fb3"; cxt.strokeStyle = "#fd5"; cxt.lineWidth = 3; cxt.save(); cxt.transform(R, 0, 0, R, x, y); // cxt.translate(x, y); cxt.rotate(rot/180*Math.PI); // cxt.scale(R, R); starPath(cxt); cxt.fill(); cxt.stroke(); cxt.restore(); &#125; function starPath(cxt)&#123; cxt.beginPath(); for(var i = 0; i &lt; 5; i ++)&#123; cxt.lineTo(Math.cos((18 + i*72 ) / 180 * Math.PI), -Math.sin((18 + i*72) / 180 * Math.PI) ); cxt.lineTo(Math.cos((54 + i*72) / 180 * Math.PI) * 0.5, -Math.sin((54 + i*72 ) / 180 * Math.PI) * 0.5); &#125; cxt.setTransform(1, 0, 0, 1, 0, 0);//清除上一次的影响 cxt.closePath(); &#125;&lt;/script&gt; fillStyle - 线性渐变&amp;径向渐变 线性渐变 //step1 var grd = context.createLinearGradient(xstart, ystart, xend, yend); //step2 grd.addColorStop(stop, color); 12345678910111213141516171819&lt;canvas id="canvas"&gt;&lt;/canvas&gt;&lt;script&gt; window.onload = function () &#123; var canvas = document.getElementById("canvas"); canvas.width = 800; canvas.height = 800; var context = canvas.getContext("2d"); var linearGrad = context.createLinearGradient(0, 0, 800, 800); linearGrad.addColorStop(0.0, 'white'); linearGrad.addColorStop(0.25, 'yellow'); linearGrad.addColorStop(0.5, 'green'); linearGrad.addColorStop(0.75, 'blue'); linearGrad.addColorStop(1.0, 'black'); context.fillStyle = linearGrad; context.fillRect(0, 0, 800, 800); &#125;&lt;/script&gt; 径向渐变 //step1 var grd = context.createRadialGradient(x0, y0, r0, x1, y1, r1); //step2 grd.addColorStop(stop, color); 12345678910111213141516171819&lt;canvas id="canvas"&gt;&lt;/canvas&gt;&lt;script&gt; window.onload = function () &#123; var canvas = document.getElementById("canvas"); canvas.width = 800; canvas.height = 800; var context = canvas.getContext("2d"); var linearGrad = context.createRadialGradient(400, 400, 100, 400, 400, 400); linearGrad.addColorStop(0.0, 'white'); linearGrad.addColorStop(0.25, 'yellow'); linearGrad.addColorStop(0.5, 'green'); linearGrad.addColorStop(0.75, 'blue'); linearGrad.addColorStop(1.0, 'black'); context.fillStyle = linearGrad; context.fillRect(0, 0, 800, 800); &#125;&lt;/script&gt; 5. createPattern createPattern(img, repeat-style)repeat-style:no-repeat; repeat-x; repeat-y; repeat createPattern(canvas, repeat-style) createPattern(video, repeat-style) 曲线绘制圆或圆弧context.arc(context, center, radius, startingAngle, endingAngle, anticlockwiae)anticlockwiae = false 顺时针12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;canvas id="canvas"&gt;&lt;/canvas&gt;&lt;script&gt; window.onload = function()&#123; var canvas = document.getElementById("canvas"); canvas.width = 1024; canvas.height = 768; var context = canvas.getContext("2d"); context.lineWidth = 2; context.strokeStyle = "#058"; for(var i = 0; i &lt; 10; i ++)&#123; context.beginPath(); context.arc(50 + i*100, 60, 40, 0,2*Math.PI*(i+1)/10); context.closePath();//会自动闭合 context.stroke() &#125; for(var i = 0; i &lt; 10; i ++)&#123; context.beginPath(); context.arc(50 + i*100, 180, 40, 0,2*Math.PI*(i+1)/10); context.stroke() &#125; for(var i = 0; i &lt; 10; i ++)&#123; context.beginPath(); context.arc(50 + i*100, 300, 40, 0,2*Math.PI*(i+1)/10, true); context.closePath();//会自动闭合 context.stroke() &#125; for(var i = 0; i &lt; 10; i ++)&#123; context.beginPath(); context.arc(50 + i*100, 420, 40, 0,2*Math.PI*(i+1)/10, true); context.stroke() &#125; context.fillStyle = "#0f0"; for(var i = 0; i &lt; 10; i ++)&#123; context.beginPath(); context.arc(50 + i*100, 540, 40, 0,2*Math.PI*(i+1)/10, true); context.closePath();//会自动闭合 context.fill() &#125; for(var i = 0; i &lt; 10; i ++)&#123; context.beginPath(); context.arc(50 + i*100, 660, 40, 0,2*Math.PI*(i+1)/10, true); context.fill() &#125; &#125;&lt;/script&gt; arcTocontext.arcTo(x1, y1, x2, y2, radius)123456789101112131415&lt;canvas id="canvas"&gt;&lt;/canvas&gt;&lt;script&gt; window.onload = function () &#123; var canvas = document.getElementById("canvas"); canvas.width = 1800; canvas.height = 1800; var context = canvas.getContext("2d"); context.moveTo(400,100) context.arcTo(1200,400,400,700,400); context.strokeStyle= "red" context.stroke() &#125;&lt;/script&gt; 贝赛尔曲线 Bezier（1）QuadraticCurveTo(二次)context.moveTo(x0, y0); //初始点contextquadraticCurveTo(x1, y1, x2, y2)//控制点、结束点（2）BezierCurveTo(三次)context.moveTo(x0, y0);context.bezierCurveTo(x1, y1, x2, y2, x3, y3);12345678910111213141516171819function drawLand(cxt)&#123; cxt.save(); cxt.beginPath(); cxt.moveTo(0, 600); cxt.bezierCurveTo(540, 400, 660, 800, 1200, 600); cxt.lineTo(1200, 800); cxt.lineTo(0, 800); cxt.closePath(); var lanStyle = cxt.createLinearGradient(0, 800, 0, 0); lanStyle.addColorStop(0.0, "#030"); lanStyle.addColorStop(1.0, "#580"); cxt.fillStyle = lanStyle; cxt.fill(); cxt.restore();&#125; 文字渲染基础context.font = “bold 40px Arial”;context.fillText(String, x, y, [maxlen]);context.StrokeText(String, x, y, [maclen])1234567891011121314151617181920212223&lt;canvas id="canvas"&gt;&lt;/canvas&gt;&lt;script&gt; window.onload = function () &#123; var canvas = document.getElementById("canvas"); canvas.width = 800; canvas.height = 800; var context = canvas.getContext("2d"); context.font = "bold 40px Arial"; context.fillStyle = "#058"; context.fillText("欢迎学习Canvas！欢迎学习Canvas！", 40, 100); context.lineWidth = 1; context.strokeStyle = "#058"; context.strokeText("欢迎学习Canvas！欢迎学习Canvas！", 40, 200); context.fillText("欢迎学习Canvas！欢迎学习Canvas！", 40, 300, 400); context.strokeText("欢迎学习Canvas！欢迎学习Canvas！", 40, 400, 400); &#125;&lt;/script&gt; font默认值”20px sans-serif”（1）font-style:normal(default);italic(斜体字);oblique(倾斜字体)（2）font-variant:normal;small-caps(以小型形式显示大写字母)（3）font-weight:lighter;normal;bold;bolder;100,200,300,400(normal),500,600,700(bold),800,900（4）font-size:20px;2em;150%;（5）font-family:设置多种字体备选；支持@font-faceweb安全字体1234567891011121314151617181920212223242526272829303132&lt;canvas id="canvas"&gt;&lt;/canvas&gt;&lt;script&gt; window.onload = function () &#123; var canvas = document.getElementById("canvas"); canvas.width = 800; canvas.height = 800; var context = canvas.getContext("2d"); context.font = "bold 40px Arial"; var linearGrad = context.createLinearGradient(0, 0, 700, 0); linearGrad.addColorStop(0.0, 'tomato'); linearGrad.addColorStop(0.25, 'yellow'); linearGrad.addColorStop(0.5, 'green'); linearGrad.addColorStop(0.75, 'pink'); linearGrad.addColorStop(1.0, 'red'); context.fillStyle = linearGrad; // context.fillStyle = "#058"; context.fillText("欢迎学习Canvas！欢迎学习Canvas！", 40, 100); context.lineWidth = 1; context.strokeStyle = "#058"; context.strokeText("欢迎学习Canvas！欢迎学习Canvas！", 40, 200); context.fillText("欢迎学习Canvas！欢迎学习Canvas！", 40, 300, 400); context.strokeText("欢迎学习Canvas！欢迎学习Canvas！", 40, 400, 400); &#125;&lt;/script&gt; 文本对齐context.textAlign = left/center/rightcotext.textBaseline = top/middle/bottom (alphabetic拉丁/ideographic汉，日/hanging印) 文本度量context.measureText(String).width 阴影context.shadowColor;context.shadowOffsetX;//x位移值context.shadowOffsetY;//y位移值xontext.shadowBlur; //模糊值 global globalAlpha = 1(default) //使全局具有透明度 glibalCompositeOperation//绘制的图像在重叠时产生的效果“sourece-over” - 后绘制的图像在先绘制的图形上面“destination-over” - 先绘制的图形在后悔值的上面·······················································································source-oversource-atopsource-insource-out·················································································destination-overdestination-atopdestination-indestination-out·················································································lightercopyxor 剪辑区域context.clip(); 剪纸效果非零环绕原则 其他 clearRectcontext.clearRect(x, y, width, height) isPointInPathcontext.isPointInPath(x, y)var x = event.clientX - canvas.getBoundingClientRect().leftvar y = event.clientY - canvas.getBoundingClientRect().Right 兼容性explorecanvas https://code.google.con/p/explorecanvas/canvas 图形库：canvasplus/ArtisanJS/Rgraph]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongoose操作mongoDB笔记]]></title>
    <url>%2F2019%2F04%2F20%2F008-mongoose%E6%93%8D%E4%BD%9CmongoDB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Mongoose第三方包mongoose基于MongoDB官方的mongdb包在一级做了封装 网址： https://mongoosejs.com/ 起步 安装 1npm i mongoose helloworld 123456789101112const mongoose = require('mongoose');mongoose.connect('mongodb://localhost:27017/test', &#123;useNewUrlParser: true&#125;);//创建一个模型，就是在设计数据库const Cat = mongoose.model('Cat', &#123; name: String &#125;);//实例化一个catconst kitty = new Cat(&#123; name: 'Zildjian' &#125;);//持久化保存kitty实例kitty.save().then(() =&gt; console.log('meow')); 官方指南官方增删查改demo 设计Schema发布Model12345678910111213141516171819202122232425262728293031323334353637var mongoose = require('mongoose')var Schema = mongoose.Schema// 1. 连接数据库// 指定连接的数据库不需要存在，当你插入第一条数据之后就会自动被创建出来mongoose.connect('mongodb://localhost/itcast')// 2. 设计文档结构（表结构）// 字段名称就是表结构中的属性名称// 约束的目的是为了保证数据的完整性，不要有脏数据var userSchema = new Schema(&#123; username: &#123; type: String, required: true // 必须有 &#125;, password: &#123; type: String, required: true &#125;, email: &#123; type: String &#125;&#125;)// 3. 将文档结构发布为模型// mongoose.model 方法就是用来将一个架构发布为 model// 第一个参数：传入一个大写名词单数字符串用来表示你的数据库名称// mongoose 会自动将大写名词的字符串生成 小写复数 的集合名称// 例如这里的 User 最终会变为 users 集合名称// 第二个参数：架构 Schema// // 返回值：模型构造函数var User = mongoose.model('User', userSchema)// 4. 当我们有了模型构造函数之后，就可以使用这个构造函数对 users 集合中的数据为所欲为了（增删改查） 增加数据1234567891011121314let admin = new User(&#123; username:'admin', password:'123456', email:'admin@admin.com'&#125;)admin.save((err, ret)=&gt;&#123; if(err)&#123; console.log('err') &#125;else&#123; console.log('success') console.log(ret) &#125;&#125;) 查询查询所有： 1234567User.find((err, ret)=&gt;&#123; if(err)&#123; console.log('err') &#125;else&#123; console.log(ret) &#125;&#125;) 按条件查询所有： 1234567User.find(&#123;username:'ss'&#125;,(err, ret)=&gt;&#123; if(err)&#123; console.log('err') &#125;else&#123; console.log(ret) &#125;&#125;) 按条件查询单个： 123456789User.findOne(&#123; username:'ss'&#125;,(err, ret)=&gt;&#123; if(err)&#123; console.log('err') &#125;else&#123; console.log(ret) &#125;&#125;) 删除数据deleteOne(), deleteMany() 12345678910User.deleteOne(&#123; username:'ss'&#125;,(err, ret)=&gt;&#123; if(err)&#123; console.log('err') &#125;else&#123; console.log('sucdccess') console.log(ret) &#125;&#125;) 更新数据 findByIdAndUpdate() 123456789User.findByIdAndUpdate('5c822c27de309b2e200fac3d',&#123; password:'123'&#125;,(err, ret)=&gt;&#123; if(err)&#123; console.log('err') &#125;else&#123; console.log('success') &#125;&#125;) findeOneAndUpdate() 12345var query = &#123; name: 'borne' &#125;;Model.findOneAndUpdate(query, &#123; name: 'jason bourne' &#125;, options, callback)// is sent asModel.findOneAndUpdate(query, &#123; $set: &#123; name: 'jason bourne' &#125;&#125;, options, callback)]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this指向小结]]></title>
    <url>%2F2019%2F04%2F20%2F006-this%E6%8C%87%E5%90%91%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在全局环境下，this 始终指向全局对象（window），无论严格与否 函数上下文调用 函数直接调用 非严格模式：this 指向全局对象 window 严格模式：this 为 undefined 对象中的 this 函数的定义位置不影响其 this 指向，this 指向只和调用函数的对象有关。 多层嵌套的对象，内部方法的 this 指向离被调用函数最近的对象（window 也是对象，其内部对象调用方法的 this 指向内部对象， 而非 window）。 原型链中的 this，指向调用它的对象（谁调用指向谁），以上对于函数作为 getter &amp; setter 调用时同样适用。 构造函数中，构造函数中的 this 与被创建的新对象绑定。 注意：当构造器返回的默认值是一个 this 引用的对象时，可以手动设置返回其他的对象，如果返回值不是一个对象，返回 this。 call&amp;apply 当函数通过 Function 对象的原型中继承的方法 call() 和 apply() 方法调用时， 其函数内部的 this 值可绑定到 call() &amp; apply() 方法指定的第一个对象上， 如果第一个参数不是对象，JavaScript 内部会尝试将其转换成对象然后指向它。 bind bind 方法在 ES5 引入， 在 Function 的原型链上， Function.prototype.bind。通过 bind 方法绑定后， 函数将被永远绑定在其第一个参数对象上， 而无论其在什么情况下被调用。 DOM 事件处理函数中的 this &amp; 内联事件中的 this DOM 事件处理函数：当函数被当做监听事件处理函数时，其 this 指向触发该事件的元素（针对 addEvenetListener） 内联事件 当代码被内联处理函数调用时，它的 this 指向监听器所在元素 当代码被包括在函数内部执行时，其 this 指向等同于函数直接调用的情况， 在非严格模式下指向全局对象 window 在严格模式下指向 undefined setTineout&amp;setInterval 对于延时函数内部的回调函数的 this 指向全局对象 window（当然我们可以通过 bind 方法改变其内部函数的 this 指向） 箭头函数中的 this 由于箭头函数不绑定 this， 它会捕获其所在（即定义的位置）上下文的 this 值， 作为自己的 this 值， 所以 call() / apply() / bind() 方法对于箭头函数来说只是传入参数，对它的 this 毫无影响。 考虑到 this 是词法层面上的，严格模式中与 this 相关的规则都将被忽略。（可以忽略是否在严格模式下的影响） 作为方法的箭头函数 this 指向全局 window 对象，而普通函数则指向调用它的对象 参考：https://www.cnblogs.com/dongcanliang/p/7054176.html]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[== & === & Object.is()]]></title>
    <url>%2F2019%2F04%2F20%2F004-%E5%85%A8%E7%AD%89%E3%80%81%E5%8F%8C%E7%AD%89%E4%B8%8EObject-is%2F</url>
    <content type="text"><![CDATA[== == 会进行隐式类型转换 undefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。 12345678910false == null // falsefalse == undefined // flasenull == undefined // true'' == '0' // false0 == '' // true0 == '0' // truefalse == "false" // falsefalse == '0' // true 一个基本数据类型与一个引用数据类型 ：会将对象转化为它的原始值，在与基本数据类型进行比较。 123var arr = [1,2];var str = "1,2";alert(arr == str); //内部执行valueOf()，将arr值转化为原始值，但是arr并没有变化，显示true === === 严格等于， 要求类型相同，并且值相等；类型不同就会返回false 数值比较时，如果有一个是NaN，则不相等。 NaN === NaN // false 判断一个值是否是NaN可以用isNaN()或者Object.is() +0 === -0 // true Object.is() Object.is() ES6新增的用来比较严格相等的方法，基本行为与 === 一致 不同之处： Object.is(+0, -0) //false Object.is(NaN, NaN) //true]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[for、for...of、for...in]]></title>
    <url>%2F2019%2F04%2F20%2F003-for%E3%80%81for-of%E3%80%81for-in%2F</url>
    <content type="text"><![CDATA[for 、for…of、for…in区别 forEach() foeEach()不能使用break语句跳出循环，或者使用return从函数体内返回 for-in() 为循环“enumerable”对象设计的 循环遍历对象自身和继承的可枚举属性（不含Symbol） 会循环原型链和手动添加的键，返回键名key 某些情况下，循环顺序随机的 for-of()（ES6） 可以使用break,continue,return 支持数组和类数组对象的遍历，循环读取键值 也支持字符串的遍历]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[undefined与null]]></title>
    <url>%2F2019%2F04%2F20%2F002-undefined%E4%B8%8Enull%2F</url>
    <content type="text"><![CDATA[undefined与null的区别undefined与null 都是JS的原始类型， null转换为数值为0，undefined转换为数值为NaN undefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。 undefined 当声明的变量还未被初始化时，变量的默认值为undefined 调用函数时，应该提供的参数没提供，则该参数为undefined 函数没有返回值时，默认返回undefined 对象没有赋值的属性 null null表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象 作为函数的参数，表示参数不是对象 作为对象原型链的终点( Object.getPrototypeOf(Object.prototype) ) 1234567typeof( undefined ) //undefinedtypeof( null ) // objectnull == undefined //truenull === undefined // false]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
</search>
