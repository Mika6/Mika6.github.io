---
title: 文本溢出&内容溢出
date: 2019-04-24 23:15:50
tags: 性能优化
categories: 性能优化
---

前端性能优化，大方向来讲，可从两方面入手，网络层面与页面渲染层面

## 网络层面

从输入 url 到显示页面，在网络层面主要包含三个过程：
1 DNS 解析
2 TCP 连接
3 HTTP 请求与响应

### 请求过程优化（http 请求优化）

http 请求优化主要有两个方向：
1 减少请求次数
2 减少单次请求消耗的时间

#### 构建工具性能调优

- 减少 loader 所做的事情
  1 用 include、exclude 来避免不必要的转译
  2 将转移结果缓存文件系统
- 借助其他工具将第三方依赖单独打包
- 文件结构可视化，寻找体积过大的原因
- 删除冗余代码
- 按需加载

#### 图片性能优化

- JPEG/JPE
  特点： 有损压缩，体积小，加载快，不支持透明
  使用场景：呈现色彩丰富的图片，如大的背景图，轮播图
- png-8/png-24
  特点：支持透明，体积大
  使用场景：线条颜色对比强烈的颜色和背景，如 logo
- SVG
  特点：文本文件，体积小不失真，兼容性好，但渲染成本较高
- base64
  特点：文本文件，依赖编码，小图标解决方案
  base64 是一种编码方式，不是图片格式
  使用 base64 也是为了减少请求次数，是作为 CSS sprite 的补充而存在，
  是一种用于传输 8bit 字节码的编码方式，通过对图片进行 base64 编码，可以直接将编码结果写入 HTML 或者 CSS，从而减少 http 请求。
- webP
  特点：全能，兼容差
  google 开发的旨在加快图片加载速度，支持有损压缩与无损压缩

### 减少网络请求

减少网络请求 => 存储 => 1 浏览器缓存机制 2 本地存储

#### 浏览器缓存机制

缓存能够减少 IO 消耗，提高访问速度，浏览器缓存是一种操作简单、效果显著的前端性能优化手段。
浏览器缓存机制包含四个方面(按照资源获取请求优先级)：
1 Memory Cache
2 Service Worker Cache
3 HTTP Cache
4 Push Cache

##### Memory Cache 内存中的缓存

浏览器最先尝试命中，响应速度最快
它与渲染进程存在生死相依的关系，当进程结束后，内存中的数据也就不存在了

##### Service Worker Cache

- Service Worker 是一种独立于主线程之外的 JavaScript 线程，它脱离浏览器窗体，因此无法直接访问 DOM。也就使得它的行为无法干扰到页面的性能，因此，借助它我们可以实现离线缓存，消息推送，网络代理等功能。借助 Service Worker 实现的离线缓存就称为`Service Work Cache`
- Service Worker 的生命周期包括`install`, `active`, `working`三个阶段。一旦 install ，除非主动终止，就将始终存在，只会在 active 和 working 之间切换。
- Service Worker 对协议有要求，以 HTTPS 为前提。
- **注意：**
  Service Worker 处理网络请求的后台服务，通信使用 postMessage
  Web Worker 模仿多线程，通信使用 postMessage
  websocket 在客户端与服务端之间创建一个开放的连接，允许在一个连接导航进行双向通信

##### HTTP Cache

http 缓存分为强缓存与协商缓存,强缓存的优先级高于协商缓存，在强缓存命中失败时，才会走协商缓存。

###### 强缓存

强缓存是利用 http 头部的 Expries 和 Cache-Control 来控制，当强缓存命中后，不会再与服务器发生通信。
服务器返回响应时，在 Response Headers 中将过期时间写入 expires 字段；
exprise 是一个时间戳 => 依赖本地时间 => 服务器和客户端时间可能不同，也可手动更改 => 无法达到预期 => http1.1 增加了 Cache-Control
**Cache-Control 相对于 expires 更加准确，它的优先级也更高。当 Cache-Control 与 expires 同时出现时，我们以 Cache-Control 为准。**

```js
cache-control: max-age=3600, s-maxage=31536000
```

s-maxage 优先级高于 max-age，两者同时出现时，优先考虑 s-maxage。如果 s-maxage 未过期，则向代理服务器请求其缓存内容。s-maxage 仅在代理服务器中生效，客户端中我们只考虑 max-age。
**public 与 private**
public 与 private 是针对资源是否能够被代理服务缓存而存在的一组对立概念。
public：即可被浏览器缓存，又可以被代理服务器缓存。
private：默认值，只能被浏览器缓存。
**no-store 与 no-cache**
no-cahe: 不会向浏览器询问，直接向服务器询问 => 进入协商缓存。
no-store：不使用任何缓存，直接向服务器发起请求，并下载完整的响应。

###### 协商缓存

协商缓存依赖浏览器与服务器之间的通信
协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，如果服务端提示资源未改动，资源会被重定向到浏览器缓存，对应状态码是 `304 Not Modified`
Last-Modified 是一个时间戳，首次请求时随着响应头返回
下次请求时，会带上 `If-Modefied-Since`，它的值就是上次返回的 Last-Modified
它的缺点：
1 我们编辑了文件，但文件的内容没有改变。会被当做新资源，进而引发一次完整的响应——不该重新请求的时候，也会重新请求。
2 当我们修改文件的速度过快时（比如花了 100ms 完成了改动），由于 If-Modified-Since 只能检查到以秒为最小计量单位的时间差，所以它是感知不到这个改动的——该重新请求的时候，反而没有重新请求了。
=> 于是出现 Etag
Etag 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的。
首次请求时，响应头部会带有`Etag`字段
下次请求时就会带上一个`If-None-Match`字段，值为上次 Etag，以供服务器比较
**Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。**

##### Push Cache

Push Cache 是指 HTTP2 在 server push 阶段存在的缓存
一些特性：
Push Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。
Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。
不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。

#### 本地存储

##### Cookie

http 是无状态的，Cookie 的本职工作就是用来维持状态的。
Cookie 性能缺陷：
Cookie 的体积上限为 4KB，超过将被裁剪，只能用来存储少量信息
Cookie 是紧跟域名的，默认为 Cookie 页面的主机名，也可手动设置
同一个域名下的所有请求都会携带 Cookie，哪怕是一张图片一个 css 文件，容易影响性能。

##### Web Storage

Web Storage 是 HTML5 专门为浏览器存储而提供的数据存储机制。它又分为 Local Storage 与 Session Storage。

- Web Storage 的特点：
  存储容量大：根据浏览器的不同可达 5-10M
  仅位于浏览器端，不予服务器发生通信。
- Local Storage 与 Session Storage 的区别
  生命周期：Local Storage 是持久的本地存储，Session Storage 是临时的本地存储，会话级别，页面关闭时，它也就随之释放
  作用域：两者都遵循同源策略；但 Session Storage 特别的一点在于，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 Session Storage 内容便无法共享。
- 应用场景
  Local Storage 在存储方面没有什么特别的限制，理论上 Cookie 无法胜任的、可以用简单的键值对来存取的数据存储任务，都可以交给 Local Storage 来做。
  Session Storage 更适合用来存储生命周期和它同步的会话级别的信息。

##### indexDB

IndexedDB 是一个运行在浏览器上的非关系型数据库。
IndexedDB 可以看做是 LocalStorage 的一个升级，当数据的复杂度和规模上升到了 LocalStorage 无法解决的程度，可以请出 IndexedDB 来帮忙。
